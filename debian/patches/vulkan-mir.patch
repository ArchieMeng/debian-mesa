--- a/configure.ac
+++ b/configure.ac
@@ -2164,6 +2164,7 @@ fi
 
 AM_CONDITIONAL(HAVE_PLATFORM_X11, echo "$egl_platforms" | grep -q 'x11')
 AM_CONDITIONAL(HAVE_PLATFORM_WAYLAND, echo "$egl_platforms" | grep -q 'wayland')
+AM_CONDITIONAL(HAVE_PLATFORM_RS, echo "$egl_platforms" | grep -q 'rs')
 AM_CONDITIONAL(HAVE_EGL_PLATFORM_DRM, echo "$egl_platforms" | grep -q 'drm')
 AM_CONDITIONAL(HAVE_EGL_PLATFORM_SURFACELESS, echo "$egl_platforms" | grep -q 'surfaceless')
 AM_CONDITIONAL(HAVE_EGL_PLATFORM_ANDROID, echo "$egl_platforms" | grep -q 'android')
--- a/src/intel/vulkan/Makefile.am
+++ b/src/intel/vulkan/Makefile.am
@@ -120,6 +120,17 @@ VULKAN_LIB_DEPS += \
 	$(WAYLAND_LIBS)
 endif
 
+if HAVE_PLATFORM_RS
+AM_CPPFLAGS += \
+	$(RS_CFLAGS) \
+	-DVK_USE_PLATFORM_MIR_KHR
+
+VULKAN_SOURCES += $(VULKAN_WSI_MIR_FILES)
+
+VULKAN_LIB_DEPS += \
+	$(RS_LIBS)
+endif
+
 noinst_LTLIBRARIES += libvulkan_common.la
 libvulkan_common_la_SOURCES = $(VULKAN_SOURCES)
 
--- a/src/intel/vulkan/Makefile.sources
+++ b/src/intel/vulkan/Makefile.sources
@@ -51,6 +51,9 @@ VULKAN_WSI_WAYLAND_FILES := \
 VULKAN_WSI_X11_FILES := \
 	anv_wsi_x11.c
 
+VULKAN_WSI_MIR_FILES := \
+	anv_wsi_mir.c
+
 VULKAN_GEM_FILES := \
 	anv_gem.c
 
--- a/src/intel/vulkan/anv_device.c
+++ b/src/intel/vulkan/anv_device.c
@@ -253,6 +253,12 @@ static const VkExtensionProperties globa
       .specVersion = 5,
    },
 #endif
+#ifdef VK_USE_PLATFORM_MIR_KHR
+   {
+      .extensionName = VK_KHR_MIR_SURFACE_EXTENSION_NAME,
+      .specVersion = 4,
+   },
+#endif
 };
 
 static const VkExtensionProperties device_extensions[] = {
@@ -293,6 +299,69 @@ static const VkAllocationCallbacks defau
    .pfnFree = default_free_func,
 };
 
+static VkResult
+anv_bo_import_prime_fd(struct anv_bo *bo, struct anv_device *device, uint64_t size, int fd)
+{
+   bo->gem_handle = anv_gem_fd_to_handle(device, fd);
+   if (!bo->gem_handle)
+      return vk_error(VK_ERROR_OUT_OF_DEVICE_MEMORY);
+
+   bo->map = NULL;
+   bo->index = 0;
+   bo->offset = 0;
+   bo->size = size;
+   bo->is_winsys_bo = false;
+
+   return VK_SUCCESS;
+}
+
+VkResult anv_ImportAllocatedMemory(
+   VkDevice                                    _device,
+   int                                         fd,
+   const VkMemoryAllocateInfo*                 pAllocateInfo,
+   const VkAllocationCallbacks*                pAllocator,
+   VkDeviceMemory*                             pMem)
+{
+   ANV_FROM_HANDLE(anv_device, device, _device);
+   struct anv_device_memory *mem;
+   VkResult result;
+
+   assert(pAllocateInfo->sType == VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO);
+
+   if (pAllocateInfo->allocationSize == 0) {
+      /* Apparently, this is allowed */
+      *pMem = VK_NULL_HANDLE;
+      return VK_SUCCESS;
+   }
+
+   /* We support exactly one memory heap. */
+   assert(pAllocateInfo->memoryTypeIndex == 0 ||
+          (!device->info.has_llc && pAllocateInfo->memoryTypeIndex < 2));
+
+   mem = vk_alloc2(&device->alloc, pAllocator, sizeof(*mem), 8,
+                    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+   if (mem == NULL)
+      return vk_error(VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   /* The kernel is going to give us whole pages anyway */
+   uint64_t alloc_size = align_u64(pAllocateInfo->allocationSize, 4096);
+
+   result = anv_bo_import_prime_fd(&mem->bo, device, alloc_size, fd);
+   if (result != VK_SUCCESS)
+      goto fail;
+
+   mem->type_index = pAllocateInfo->memoryTypeIndex;
+
+   *pMem = anv_device_memory_to_handle(mem);
+
+   return VK_SUCCESS;
+
+fail:
+   vk_free2(&device->alloc, pAllocator, mem);
+
+   return result;
+}
+
 VkResult anv_CreateInstance(
     const VkInstanceCreateInfo*                 pCreateInfo,
     const VkAllocationCallbacks*                pAllocator,
--- a/src/intel/vulkan/anv_private.h
+++ b/src/intel/vulkan/anv_private.h
@@ -72,6 +72,13 @@ struct gen_l3_config;
 extern "C" {
 #endif
 
+VkResult anv_ImportAllocatedMemory(
+   VkDevice                                    _device,
+   int                                         fd,
+   const VkMemoryAllocateInfo*                 pAllocateInfo,
+   const VkAllocationCallbacks*                pAllocator,
+   VkDeviceMemory*                             pMem);
+
 /* Allowing different clear colors requires us to perform a depth resolve at
  * the end of certain render passes. This is because while slow clears store
  * the clear color in the HiZ buffer, fast clears (without a resolve) don't.
--- a/src/intel/vulkan/anv_wsi.c
+++ b/src/intel/vulkan/anv_wsi.c
@@ -54,12 +54,28 @@ anv_init_wsi(struct anv_physical_device
    }
 #endif
 
+#ifdef VK_USE_PLATFORM_MIR_KHR
+   result = wsi_mir_init_wsi(&physical_device->wsi_device, &physical_device->instance->alloc);
+   if (result != VK_SUCCESS) {
+#ifdef VK_USE_PLATFORM_WAYLAND_KHR
+      wsi_wl_finish_wsi(&physical_device->wsi_device, &physical_device->instance->alloc);
+#endif
+#ifdef VK_USE_PLATFORM_XCB_KHR
+      wsi_x11_finish_wsi(&physical_device->wsi_device, &physical_device->instance->alloc);
+#endif
+      return result;
+   }
+#endif
+
    return VK_SUCCESS;
 }
 
 void
 anv_finish_wsi(struct anv_physical_device *physical_device)
 {
+#ifdef VK_USE_PLATFORM_MIR_KHR
+   wsi_mir_finish_wsi(&physical_device->wsi_device, &physical_device->instance->alloc);
+#endif
 #ifdef VK_USE_PLATFORM_WAYLAND_KHR
    wsi_wl_finish_wsi(&physical_device->wsi_device, &physical_device->instance->alloc);
 #endif
@@ -142,6 +158,7 @@ static VkResult
 x11_anv_wsi_image_create(VkDevice device_h,
                          const VkSwapchainCreateInfoKHR *pCreateInfo,
                          const VkAllocationCallbacks* pAllocator,
+                         bool import_fd,
                          VkImage *image_p,
                          VkDeviceMemory *memory_p,
                          uint32_t *size,
@@ -186,6 +203,18 @@ x11_anv_wsi_image_create(VkDevice device
 
    VkDeviceMemory memory_h;
    struct anv_device_memory *memory;
+   if (import_fd) {
+      result = anv_ImportAllocatedMemory(anv_device_to_handle(device),
+         *fd_p,
+         &(VkMemoryAllocateInfo) {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
+            .allocationSize = image->size,
+            .memoryTypeIndex = 0,
+         },
+         pAllocator,
+         &memory_h);
+   }
+   else {
    result = anv_AllocateMemory(anv_device_to_handle(device),
       &(VkMemoryAllocateInfo) {
          .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
@@ -194,13 +223,21 @@ x11_anv_wsi_image_create(VkDevice device
       },
       NULL /* XXX: pAllocator */,
       &memory_h);
+   }
    if (result != VK_SUCCESS)
       goto fail_create_image;
 
    memory = anv_device_memory_from_handle(memory_h);
-   memory->bo.is_winsys_bo = true;
 
-   anv_BindImageMemory(device_h, image_h, memory_h, 0);
+   if (import_fd) {
+       // Do we need to do more of what anv_BindImageMemory() does here?
+       image->bo = &memory->bo;
+       image->offset = 0;
+   }
+   else {
+      memory->bo.is_winsys_bo = true;
+      anv_BindImageMemory(device_h, image_h, memory_h, 0);
+   }
 
    struct anv_surface *surface = &image->color_surface;
    assert(surface->isl.tiling == ISL_TILING_X);
@@ -215,13 +252,18 @@ x11_anv_wsi_image_create(VkDevice device
       goto fail_alloc_memory;
    }
 
-   int fd = anv_gem_handle_to_fd(device, memory->bo.gem_handle);
-   if (fd == -1) {
-      /* FINISHME: Choose a better error. */
-      result = vk_errorf(VK_ERROR_OUT_OF_DEVICE_MEMORY,
-                         "handle_to_fd failed: %m");
-      goto fail_alloc_memory;
+   int fd;
+   if (!import_fd) {
+      fd = anv_gem_handle_to_fd(device, memory->bo.gem_handle);
+      if (fd == -1) {
+         /* FINISHME: Choose a better error. */
+         result = vk_errorf(VK_ERROR_OUT_OF_DEVICE_MEMORY,
+                            "handle_to_fd failed: %m");
+         goto fail_alloc_memory;
+      }
    }
+   else
+       fd = *fd_p;
 
    *image_p = image_h;
    *memory_p = memory_h;
@@ -240,12 +282,14 @@ fail_create_image:
 static void
 x11_anv_wsi_image_free(VkDevice device,
                        const VkAllocationCallbacks* pAllocator,
+                       bool imported_fd,
                        VkImage image_h,
                        VkDeviceMemory memory_h)
 {
    anv_DestroyImage(device, image_h, pAllocator);
 
-   anv_FreeMemory(device, memory_h, pAllocator);
+   if (!imported_fd)
+      anv_FreeMemory(device, memory_h, pAllocator);
 }
 
 static const struct wsi_image_fns anv_wsi_image_fns = {
--- /dev/null
+++ b/src/intel/vulkan/anv_wsi_mir.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright Â© 2017 Canonical Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "wsi_common_mir.h"
+#include "anv_private.h"
+
+VkBool32 anv_GetPhysicalDeviceMirPresentationSupportKHR(
+    VkPhysicalDevice physicalDevice,
+    uint32_t         queueFamilyIndex,
+    MirConnection*   connection)
+{
+   ANV_FROM_HANDLE(anv_physical_device, physical_device, physicalDevice);
+
+   return wsi_get_mir_presentation_support(&physical_device->wsi_device, connection);
+}
+
+VkResult anv_CreateMirSurfaceKHR(
+    VkInstance                       _instance,
+    const VkMirSurfaceCreateInfoKHR* pCreateInfo,
+    const VkAllocationCallbacks*     pAllocator,
+    VkSurfaceKHR*                    pSurface)
+{
+   ANV_FROM_HANDLE(anv_instance, instance, _instance);
+   const VkAllocationCallbacks *alloc;
+   assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR);
+
+   if (pAllocator)
+      alloc = pAllocator;
+   else
+      alloc = &instance->alloc;
+
+   return wsi_create_mir_surface(alloc, pCreateInfo, pSurface);
+}
--- a/src/vulkan/wsi/Makefile.am
+++ b/src/vulkan/wsi/Makefile.am
@@ -46,4 +46,16 @@ VULKAN_LIB_DEPS += \
 	$(WAYLAND_LIBS)
 endif
 
+if HAVE_PLATFORM_RS
+AM_CPPFLAGS += \
+	-I$(top_srcdir)/src/gbm/main \
+	$(RS_CFLAGS) \
+	-DVK_USE_PLATFORM_MIR_KHR
+
+VULKAN_WSI_SOURCES += $(VULKAN_WSI_MIR_FILES)
+
+VULKAN_LIB_DEPS += \
+	$(RS_LIBS)
+endif
+
 libvulkan_wsi_la_SOURCES = $(VULKAN_WSI_SOURCES)
--- a/src/vulkan/wsi/Makefile.sources
+++ b/src/vulkan/wsi/Makefile.sources
@@ -9,4 +9,8 @@ VULKAN_WSI_WAYLAND_FILES := \
 
 VULKAN_WSI_X11_FILES := \
 	wsi_common_x11.c \
-	wsi_common_x11.h
\ No newline at end of file
+	wsi_common_x11.h
+
+VULKAN_WSI_MIR_FILES := \
+	wsi_common_mir.c \
+	wsi_common_mir.h
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -35,6 +35,7 @@ struct wsi_image_fns {
    VkResult (*create_wsi_image)(VkDevice device_h,
                                 const VkSwapchainCreateInfoKHR *pCreateInfo,
                                 const VkAllocationCallbacks *pAllocator,
+                                bool import_fd,
                                 VkImage *image_p,
                                 VkDeviceMemory *memory_p,
                                 uint32_t *size_p,
@@ -43,6 +44,7 @@ struct wsi_image_fns {
                                 int *fd_p);
    void (*free_wsi_image)(VkDevice device,
                           const VkAllocationCallbacks *pAllocator,
+                          bool imported_fd,
                           VkImage image_h,
                           VkDeviceMemory memory_h);
 };
@@ -147,6 +149,9 @@ VkResult wsi_wl_init_wsi(struct wsi_devi
                          const struct wsi_callbacks *cbs);
 void wsi_wl_finish_wsi(struct wsi_device *wsi_device,
                        const VkAllocationCallbacks *alloc);
-
+VkResult wsi_mir_init_wsi(struct wsi_device *wsi_device,
+                          const VkAllocationCallbacks *alloc);
+void wsi_mir_finish_wsi(struct wsi_device *wsi_device,
+                        const VkAllocationCallbacks *alloc);
 
 #endif
--- /dev/null
+++ b/src/vulkan/wsi/wsi_common_mir.c
@@ -0,0 +1,583 @@
+/*
+ * Copyright Â© 2017 Canonical Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <mir_toolkit/mir_client_library.h>
+#include <mir_toolkit/extensions/gbm_buffer.h>
+#include <gbm.h>
+#include <errno.h>
+
+#include <util/hash_table.h>
+
+#include "wsi_common_mir.h"
+
+#define TRACE printf("%s()\n", __func__);
+
+#define typed_memcpy(dest, src, count) ({ \
+   STATIC_ASSERT(sizeof(*src) == sizeof(*dest)); \
+   memcpy((dest), (src), (count) * sizeof(*(src))); \
+})
+
+struct wsi_mir {
+   struct wsi_interface base;
+
+//   pthread_mutex_t      mutex;
+   /* Hash table of MirConnection* -> wsi_mir_connection mappings */
+//   struct hash_table    *connections;
+};
+
+static const VkSurfaceFormatKHR formats[] = {
+   { .format = VK_FORMAT_B8G8R8A8_UNORM, },
+};
+
+static const VkPresentModeKHR present_modes[] = {
+   VK_PRESENT_MODE_FIFO_KHR,
+};
+
+struct wsi_mir_image {
+   VkImage         image;
+   VkDeviceMemory  memory;
+   MirBuffer*      buffer;
+   bool            busy;
+   pthread_mutex_t lock;
+   pthread_cond_t  cv;
+};
+
+struct wsi_mir_swapchain {
+   struct wsi_swapchain  base;
+
+   MirConnection         *connection;
+   MirRenderSurface      *surface;
+   MirPresentationChain  *presentation_chain;
+
+   struct MirExtensionGbmBufferV1 const* gbm_buffer_ext;
+
+   VkExtent2D           extent;
+   VkFormat             vk_format;
+
+   VkPresentModeKHR     present_mode;
+   bool                 fifo_ready;
+   pthread_mutex_t      lock;
+   pthread_cond_t       cv;
+
+   uint32_t             image_count;
+   uint32_t             next_image_to_use;
+   struct wsi_mir_image images[0];
+};
+
+static VkResult
+wsi_mir_surface_get_support(VkIcdSurfaceBase *surface,
+                            struct wsi_device *wsi_device,
+                            const VkAllocationCallbacks *alloc,
+                            uint32_t queueFamilyIndex,
+                            VkBool32* pSupported)
+{
+   TRACE
+
+   *pSupported = true;
+
+   return VK_SUCCESS;
+}
+
+static VkResult
+wsi_mir_surface_get_capabilities(VkIcdSurfaceBase *surface,
+                                 VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
+{
+   TRACE
+
+   pSurfaceCapabilities->minImageCount = 2;
+   pSurfaceCapabilities->maxImageCount = 0; // 0 to force to maximum supported
+   pSurfaceCapabilities->currentExtent = (VkExtent2D) { -1, -1 };
+   pSurfaceCapabilities->minImageExtent = (VkExtent2D) { 1, 1 };
+   pSurfaceCapabilities->maxImageExtent = (VkExtent2D) { INT16_MAX, INT16_MAX };
+   pSurfaceCapabilities->supportedTransforms = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
+   pSurfaceCapabilities->currentTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
+   pSurfaceCapabilities->maxImageArrayLayers = 1;
+
+   pSurfaceCapabilities->supportedCompositeAlpha =
+      VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR /*|
+      VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR*/;
+
+   pSurfaceCapabilities->supportedUsageFlags =
+/*      VK_IMAGE_USAGE_TRANSFER_SRC_BIT |
+      VK_IMAGE_USAGE_SAMPLED_BIT |*/
+      VK_IMAGE_USAGE_TRANSFER_DST_BIT |
+      VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
+
+   return VK_SUCCESS;
+}
+
+static VkResult
+wsi_mir_surface_get_formats(VkIcdSurfaceBase *surface,
+                            struct wsi_device *wsi_device,
+                            uint32_t* pSurfaceFormatCount,
+                            VkSurfaceFormatKHR* pSurfaceFormats)
+{
+   TRACE
+
+   if (pSurfaceFormats == NULL) {
+      *pSurfaceFormatCount = ARRAY_SIZE(formats);
+      return VK_SUCCESS;
+   }
+
+   *pSurfaceFormatCount = MIN2(*pSurfaceFormatCount, ARRAY_SIZE(formats));
+   typed_memcpy(pSurfaceFormats, formats, *pSurfaceFormatCount);
+
+   return *pSurfaceFormatCount < ARRAY_SIZE(formats) ?
+      VK_INCOMPLETE : VK_SUCCESS;
+}
+
+static VkResult
+wsi_mir_surface_get_present_modes(VkIcdSurfaceBase *surface,
+                                  uint32_t* pPresentModeCount,
+                                  VkPresentModeKHR* pPresentModes)
+{
+   TRACE
+
+   if (pPresentModes == NULL) {
+      *pPresentModeCount = ARRAY_SIZE(present_modes);
+      return VK_SUCCESS;
+   }
+
+   *pPresentModeCount = MIN2(*pPresentModeCount, ARRAY_SIZE(present_modes));
+   typed_memcpy(pPresentModes, present_modes, *pPresentModeCount);
+
+   return *pPresentModeCount < ARRAY_SIZE(present_modes) ?
+      VK_INCOMPLETE : VK_SUCCESS;
+}
+
+static VkResult
+wsi_mir_swapchain_destroy(struct wsi_swapchain *swapchain,
+                          const VkAllocationCallbacks *pAllocator)
+{
+   TRACE
+   struct wsi_mir_swapchain *chain = (struct wsi_mir_swapchain *)swapchain;
+
+   for (uint32_t i = 0; i < chain->image_count; i++) {
+      if (chain->images[i].buffer)
+      {
+         chain->base.image_fns->free_wsi_image(chain->base.device,
+                                               pAllocator, true,
+                                               chain->images[i].image,
+                                               chain->images[i].memory);
+         mir_buffer_release(chain->images[i].buffer);
+      }
+   }
+
+   pthread_mutex_destroy(&chain->lock);
+   pthread_cond_destroy(&chain->cv);
+
+   vk_free(pAllocator, chain);
+
+   return VK_SUCCESS;
+}
+
+static VkResult
+wsi_mir_swapchain_get_images(struct wsi_swapchain *swapchain,
+                             uint32_t *pCount, VkImage *pSwapchainImages)
+{
+   TRACE
+
+   struct wsi_mir_swapchain *chain = (struct wsi_mir_swapchain *)swapchain;
+   uint32_t ret_count;
+   VkResult result;
+
+   if (pSwapchainImages == NULL) {
+      *pCount = chain->image_count;
+      return VK_SUCCESS;
+   }
+
+   result = VK_SUCCESS;
+   ret_count = chain->image_count;
+   if (chain->image_count > *pCount) {
+     ret_count = *pCount;
+     result = VK_INCOMPLETE;
+   }
+
+   for (uint32_t i = 0; i < ret_count; i++)
+      pSwapchainImages[i] = chain->images[i].image;
+
+   return result;
+}
+
+static VkResult
+wsi_mir_swapchain_acquire_next_image(struct wsi_swapchain *swap_chain,
+                                     uint64_t timeout,
+                                     VkSemaphore semaphore,
+                                     uint32_t *image_index)
+{
+//   TRACE
+   assert(semaphore == VK_NULL_HANDLE);
+   assert(timeout == UINT64_MAX);
+/*
+   printf("\tsemaphore is %snull\n",
+         (semaphore != VK_NULL_HANDLE) ? "non-" : "");
+
+   switch (timeout)
+   {
+   case 0:
+      printf("\tWill not block\n");
+      break;
+   case UINT64_MAX:
+      printf("\tWill block indefinitely\n");
+      break;
+   default:
+      printf("\tWill block %lu nsecs\n", timeout);
+      break;
+   }
+*/
+
+   struct wsi_mir_swapchain *chain = (struct wsi_mir_swapchain *)swap_chain;
+   uint32_t wrap = (chain->next_image_to_use-1)%(chain->image_count);
+   bool found = false;
+
+   do {
+      uint32_t const next_image = chain->next_image_to_use;
+      if (!chain->images[next_image].busy) {
+          found = true;
+          chain->images[next_image].busy = true;
+          *image_index = next_image;
+      }
+      else if (next_image == wrap) {
+         pthread_mutex_lock(&chain->lock);
+         pthread_cond_wait(&chain->cv, &chain->lock);
+         pthread_mutex_unlock(&chain->lock);
+      }
+
+      chain->next_image_to_use = (next_image+1)%(chain->image_count);
+   }
+   while(!found);
+
+   return VK_SUCCESS;
+}
+
+static void
+buffer_submit_callback(MirBuffer* buffer, void* context)
+{
+//    TRACE
+    struct wsi_mir_swapchain* chain = (struct wsi_mir_swapchain*) context;
+
+   for (uint32_t i = 0; i < chain->image_count; i++)
+      if (chain->images[i].buffer == buffer) {
+         pthread_mutex_lock(&chain->lock);
+         chain->images[i].busy = false;
+         pthread_mutex_unlock(&chain->lock);
+         pthread_cond_broadcast(&chain->cv);
+         return;
+      }
+}
+
+static VkResult
+wsi_mir_swapchain_queue_present(struct wsi_swapchain *swap_chain,
+                                uint32_t image_index)
+{
+//   TRACE
+   struct wsi_mir_swapchain *chain = (struct wsi_mir_swapchain *)swap_chain;
+   assert(chain->present_mode == VK_PRESENT_MODE_FIFO_KHR);
+
+   mir_presentation_chain_submit_buffer(chain->presentation_chain,
+                                        chain->images[image_index].buffer,
+                                        buffer_submit_callback,
+                                        chain);
+
+/*   printf("\tBuffer %d queued to server\n", image_index);*/
+   return VK_SUCCESS;
+}
+
+
+static void
+buffer_create_callback(MirBuffer* buffer, void* context)
+{
+   struct wsi_mir_image* image = (struct wsi_mir_image*)context;
+
+   printf("alloc'ed buffer\n");
+   pthread_mutex_lock(&image->lock);
+   image->buffer = buffer;
+   pthread_cond_broadcast(&image->cv);
+   pthread_mutex_unlock(&image->lock);
+}
+
+static VkResult
+wsi_mir_image_init(struct wsi_mir_swapchain *chain,
+                   struct wsi_mir_image *mir_image,
+                   const VkSwapchainCreateInfoKHR *pCreateInfo,
+                   const VkAllocationCallbacks* pAllocator)
+{
+   TRACE
+
+   VkResult result;
+
+   pthread_cond_init(&mir_image->cv, NULL);
+   pthread_mutex_init(&mir_image->lock, NULL);
+
+   printf("to alloc buffer\n");
+   chain->gbm_buffer_ext->allocate_buffer_gbm(
+      chain->connection,
+      chain->extent.width,
+      chain->extent.height,
+      GBM_FORMAT_ARGB8888, // TODO: map the actual vk format
+      GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING,
+      buffer_create_callback,
+      mir_image);
+
+   pthread_mutex_lock(&mir_image->lock);
+   while(!mir_image->buffer)
+      pthread_cond_wait(&mir_image->cv, &mir_image->lock);
+   pthread_mutex_unlock(&mir_image->lock);
+
+   MirBufferPackage* mbp = mir_buffer_get_buffer_package(mir_image->buffer);
+/*   DUMP_MirBufferPackage(mbp);
+*/
+   uint32_t size;
+   uint32_t row_pitch;
+   uint32_t offset;
+   VkDevice vk_device = chain->base.device;
+
+   printf("to wrap buffer\n");
+   result = chain->base.image_fns->create_wsi_image(vk_device,
+                                                    pCreateInfo,
+                                                    pAllocator,
+                                                    true,
+                                                    &mir_image->image,
+                                                    &mir_image->memory,
+                                                    &size,
+                                                    &offset,
+                                                    &row_pitch,
+                                                    &mbp->fd[0]);
+
+   printf("wrapped buffer\n");
+   return result;
+}
+
+static VkResult
+wsi_mir_surface_create_swapchain(VkIcdSurfaceBase *surface,
+                                 VkDevice device,
+                                 struct wsi_device *wsi_device,
+                                 const VkSwapchainCreateInfoKHR* pCreateInfo,
+                                 const VkAllocationCallbacks* pAllocator,
+                                 const struct wsi_image_fns *image_fns,
+                                 struct wsi_swapchain **swapchain)
+{
+   TRACE
+
+   VkIcdSurfaceMir *mir_surface = (VkIcdSurfaceMir *)surface;
+   struct wsi_mir_swapchain *chain;
+   VkResult result;
+
+   assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR);
+
+   int num_images = pCreateInfo->minImageCount;
+
+   size_t size = sizeof(*chain) + num_images * sizeof(chain->images[0]);
+   chain = vk_alloc(pAllocator, size, 8,
+                    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+   if (chain == NULL)
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+   chain->base.device = device;
+   chain->base.destroy = wsi_mir_swapchain_destroy;
+   chain->base.get_images = wsi_mir_swapchain_get_images;
+   chain->base.acquire_next_image = wsi_mir_swapchain_acquire_next_image;
+   chain->base.queue_present = wsi_mir_swapchain_queue_present;
+   chain->base.image_fns = image_fns;
+   chain->base.present_mode = pCreateInfo->presentMode;
+   chain->connection = mir_surface->connection;
+   chain->surface = mir_surface->mirSurface;
+   chain->extent = pCreateInfo->imageExtent;
+   chain->vk_format = pCreateInfo->imageFormat;
+
+   chain->fifo_ready = true;
+
+   chain->image_count = num_images;
+   chain->next_image_to_use = 0;
+
+   /* Mark a bunch of stuff as NULL.  This way we can just call
+    * destroy_swapchain for cleanup.
+    */
+   for (uint32_t i = 0; i < chain->image_count; i++)
+      chain->images[i].buffer = NULL;
+
+   int ret = pthread_mutex_init(&chain->lock, NULL);
+   if (ret != 0) {
+      if (ret == ENOMEM) {
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      } else {
+         /* FINISHME: Choose a better error. */
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+
+      goto fail;
+   }
+
+   ret = pthread_cond_init(&chain->cv, NULL);
+   if (ret != 0) {
+      if (ret == ENOMEM) {
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      } else {
+         /* FINISHME: Choose a better error. */
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+
+      goto fail_cv;
+   }
+
+   if (!mir_render_surface_is_valid(chain->surface))
+   {
+      result = VK_ERROR_INITIALIZATION_FAILED;
+      goto fail_lock;
+   }
+
+   chain->presentation_chain = mir_render_surface_get_presentation_chain(chain->surface);
+   if (!mir_presentation_chain_is_valid(chain->presentation_chain))
+   {
+      result = VK_ERROR_INITIALIZATION_FAILED;
+      goto fail_lock;
+   }
+
+   chain->gbm_buffer_ext = mir_extension_gbm_buffer_v1(chain->connection);
+   assert(chain->gbm_buffer_ext);
+   assert(chain->gbm_buffer_ext->allocate_buffer_gbm);
+
+   for (uint32_t i = 0; i < chain->image_count; i++) {
+      result = wsi_mir_image_init(chain, &chain->images[i],
+                                  pCreateInfo, pAllocator);
+      if (result != VK_SUCCESS)
+         goto fail_lock;
+      chain->images[i].busy = false;
+   }
+
+   *swapchain = &chain->base;
+
+   return VK_SUCCESS;
+
+fail_lock:
+   pthread_mutex_destroy(&chain->lock);
+fail_cv:
+   pthread_cond_destroy(&chain->cv);
+fail:
+   wsi_mir_swapchain_destroy(&chain->base, pAllocator);
+
+   return result;
+}
+
+VkBool32
+wsi_get_mir_presentation_support(struct wsi_device *wsi_device,
+                                 MirConnection     *connection)
+{
+   TRACE
+
+   return mir_connection_is_valid(connection);
+}
+
+VkResult
+wsi_create_mir_surface(const VkAllocationCallbacks     *pAllocator,
+                       const VkMirSurfaceCreateInfoKHR *pCreateInfo,
+                       VkSurfaceKHR                    *pSurface)
+{
+   TRACE
+
+   VkIcdSurfaceMir *surface;
+
+   surface = vk_alloc(pAllocator, sizeof *surface, 8,
+                      VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+   if (surface == NULL)
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+   surface->base.platform = VK_ICD_WSI_PLATFORM_MIR;
+   surface->connection = pCreateInfo->connection;
+   surface->mirSurface = pCreateInfo->mirSurface;
+
+   *pSurface = VkIcdSurfaceBase_to_handle(&surface->base);
+   return VK_SUCCESS;
+}
+
+VkResult
+wsi_mir_init_wsi(struct wsi_device           *wsi_device,
+                 const VkAllocationCallbacks *alloc)
+{
+   TRACE
+
+   struct wsi_mir *wsi;
+   VkResult result;
+
+   wsi = vk_alloc(alloc, sizeof(*wsi), 8,
+                   VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE);
+   if (!wsi) {
+      result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      goto fail;
+   }
+
+#if 0
+   int ret = pthread_mutex_init(&wsi->mutex, NULL);
+   if (ret != 0) {
+      if (ret == ENOMEM) {
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      } else {
+         /* FINISHME: Choose a better error. */
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+
+      goto fail_alloc;
+   }
+
+   wsi->connections = _mesa_hash_table_create(NULL, _mesa_hash_pointer,
+                                              _mesa_key_pointer_equal);
+   if (!wsi->connections) {
+      result = VK_ERROR_OUT_OF_HOST_MEMORY;
+      goto fail_mutex;
+   }
+#endif
+   wsi->base.get_support = wsi_mir_surface_get_support;
+   wsi->base.get_capabilities = wsi_mir_surface_get_capabilities;
+   wsi->base.get_formats = wsi_mir_surface_get_formats;
+   wsi->base.get_present_modes = wsi_mir_surface_get_present_modes;
+   wsi->base.create_swapchain = wsi_mir_surface_create_swapchain;
+
+   wsi_device->wsi[VK_ICD_WSI_PLATFORM_MIR] = &wsi->base;
+
+   return VK_SUCCESS;
+
+#if 0
+fail_mutex:
+   pthread_mutex_destroy(&wsi->mutex);
+fail_alloc:
+   vk_free(alloc, wsi);
+#endif
+fail:
+   wsi_device->wsi[VK_ICD_WSI_PLATFORM_MIR] = NULL;
+
+   return result;
+}
+
+void
+wsi_mir_finish_wsi(struct wsi_device           *wsi_device,
+                   const VkAllocationCallbacks *alloc)
+{
+   TRACE
+   struct wsi_mir *wsi =
+      (struct wsi_mir*)wsi_device->wsi[VK_ICD_WSI_PLATFORM_MIR];
+
+   if (wsi) {
+      vk_free(alloc, wsi);
+   }
+   wsi_device->wsi[VK_ICD_WSI_PLATFORM_MIR] = NULL;
+}
--- /dev/null
+++ b/src/vulkan/wsi/wsi_common_mir.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright Â© 2017 Canonical Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+#ifndef WSI_COMMON_MIR_H
+#define WSI_COMMON_MIR_H
+
+#include "wsi_common.h"
+
+VkBool32 wsi_get_mir_presentation_support(
+    struct wsi_device *wsi_device,
+    MirConnection     *connection);
+
+VkResult wsi_create_mir_surface(
+    const VkAllocationCallbacks     *pAllocator,
+	const VkMirSurfaceCreateInfoKHR *pCreateInfo,
+	VkSurfaceKHR                    *pSurface);
+
+#endif
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -637,6 +637,7 @@ wsi_wl_image_init(struct wsi_wl_swapchai
    result = chain->base.image_fns->create_wsi_image(vk_device,
                                                     pCreateInfo,
                                                     pAllocator,
+                                                    false,
                                                     &image->image,
                                                     &image->memory,
                                                     &size,
@@ -666,7 +667,7 @@ wsi_wl_image_init(struct wsi_wl_swapchai
    return VK_SUCCESS;
 
 fail_image:
-   chain->base.image_fns->free_wsi_image(vk_device, pAllocator,
+   chain->base.image_fns->free_wsi_image(vk_device, pAllocator, false,
                                          image->image, image->memory);
 
    return result;
@@ -680,7 +681,7 @@ wsi_wl_swapchain_destroy(struct wsi_swap
 
    for (uint32_t i = 0; i < chain->image_count; i++) {
       if (chain->images[i].buffer)
-         chain->base.image_fns->free_wsi_image(chain->base.device, pAllocator,
+         chain->base.image_fns->free_wsi_image(chain->base.device, pAllocator, false,
                                                chain->images[i].image,
                                                chain->images[i].memory);
    }
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -853,6 +853,7 @@ x11_image_init(VkDevice device_h, struct
    result = chain->base.image_fns->create_wsi_image(device_h,
                                                     pCreateInfo,
                                                     pAllocator,
+                                                    false,
                                                     &image->image,
                                                     &image->memory,
                                                     &size,
@@ -902,7 +903,7 @@ fail_pixmap:
    cookie = xcb_free_pixmap(chain->conn, image->pixmap);
    xcb_discard_reply(chain->conn, cookie.sequence);
 
-   chain->base.image_fns->free_wsi_image(device_h, pAllocator,
+   chain->base.image_fns->free_wsi_image(device_h, pAllocator, false,
                                         image->image, image->memory);
 
    return result;
@@ -922,7 +923,7 @@ x11_image_finish(struct x11_swapchain *c
    cookie = xcb_free_pixmap(chain->conn, image->pixmap);
    xcb_discard_reply(chain->conn, cookie.sequence);
 
-   chain->base.image_fns->free_wsi_image(chain->base.device, pAllocator,
+   chain->base.image_fns->free_wsi_image(chain->base.device, pAllocator, false,
                                         image->image, image->memory);
 }
 
