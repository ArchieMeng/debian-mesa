--- a/configure.ac
+++ b/configure.ac
@@ -1428,7 +1428,9 @@
 
 	android|fbdev|gdi|null)
 		;;
-
+        mir)
+                PKG_CHECK_MODULES([MIR], [mirclient])
+                ;;
 	*)
 		AC_MSG_ERROR([EGL platform '$plat' does not exist])
 		;;
@@ -1457,6 +1459,7 @@
 AM_CONDITIONAL(HAVE_EGL_PLATFORM_DRM, echo "$egl_platforms" | grep 'drm' >/dev/null 2>&1)
 AM_CONDITIONAL(HAVE_EGL_PLATFORM_FBDEV, echo "$egl_platforms" | grep 'fbdev' >/dev/null 2>&1)
 AM_CONDITIONAL(HAVE_EGL_PLATFORM_NULL, echo "$egl_platforms" | grep 'null' >/dev/null 2>&1)
+AM_CONDITIONAL(HAVE_EGL_PLATFORM_MIR, echo "$egl_platforms" | grep 'mir' >/dev/null 2>&1)
 
 AM_CONDITIONAL(HAVE_EGL_DRIVER_DRI2, test "x$HAVE_EGL_DRIVER_DRI2" != "x")
 AM_CONDITIONAL(HAVE_EGL_DRIVER_GLX, test "x$HAVE_EGL_DRIVER_GLX" != "x")
--- a/include/EGL/eglplatform.h
+++ b/include/EGL/eglplatform.h
@@ -104,6 +104,13 @@
 typedef struct egl_native_pixmap_t  *EGLNativePixmapType;
 typedef void                        *EGLNativeDisplayType;
 
+#elif defined(MIR_EGL_PLATFORM)
+
+#include <mir_toolkit/mir_client_library.h>
+typedef MirEGLNativeDisplayType EGLNativeDisplayType;
+typedef void                   *EGLNativePixmapType;
+typedef MirEGLNativeWindowType  EGLNativeWindowType;
+
 #elif defined(__unix__)
 
 #ifdef MESA_EGL_NO_X11_HEADERS
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -819,10 +819,12 @@
     unsigned int pitch;
     unsigned int cpp;
     unsigned int flags;
+    unsigned int fd;    /**< Only available with DRI2_LOADER_VERSION >= 4, */
+                        /**< Only valid if name == 0 */
 };
 
 #define __DRI_DRI2_LOADER "DRI_DRI2Loader"
-#define __DRI_DRI2_LOADER_VERSION 3
+#define __DRI_DRI2_LOADER_VERSION 4
 struct __DRIdri2LoaderExtensionRec {
     __DRIextension base;
 
--- a/src/egl/drivers/dri2/Makefile.am
+++ b/src/egl/drivers/dri2/Makefile.am
@@ -63,3 +63,9 @@
 libegl_dri2_la_SOURCES += platform_drm.c
 AM_CFLAGS += -DHAVE_DRM_PLATFORM
 endif
+
+if HAVE_EGL_PLATFORM_MIR
+libegl_dri2_la_SOURCES += platform_mir.c
+AM_CFLAGS += -DHAVE_MIR_PLATFORM
+AM_CFLAGS += $(MIR_CFLAGS)
+endif
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -632,6 +632,12 @@
          return EGL_TRUE;
       return dri2_initialize_wayland(drv, disp);
 #endif
+#ifdef HAVE_MIR_PLATFORM
+   case _EGL_PLATFORM_MIR:
+      if (disp->Options.TestOnly)
+         return EGL_TRUE;
+      return dri2_initialize_mir(drv, disp);
+#endif
 #endif
 #ifdef HAVE_ANDROID_PLATFORM
    case _EGL_PLATFORM_ANDROID:
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -64,6 +64,11 @@
 
 #endif /* HAVE_ANDROID_PLATFORM */
 
+#ifdef HAVE_MIR_PLATFORM
+#include <mir_toolkit/mir_client_library.h>
+#include <mir_toolkit/mesa/native_display.h>
+#endif
+
 #include "eglconfig.h"
 #include "eglcontext.h"
 #include "egldisplay.h"
@@ -135,6 +140,10 @@
    uint32_t                  capabilities;
 #endif
 
+#ifdef HAVE_MIR_PLATFORM
+  MirMesaEGLNativeDisplay *mir_disp;
+#endif
+
    int (*authenticate) (_EGLDisplay *disp, uint32_t id);
 };
 
@@ -183,7 +192,9 @@
    struct gbm_dri_surface *gbm_surf;
 #endif
 
-#if defined(HAVE_WAYLAND_PLATFORM) || defined(HAVE_DRM_PLATFORM)
+#if defined(HAVE_WAYLAND_PLATFORM) \
+   || defined(HAVE_DRM_PLATFORM) \
+   || defined(HAVE_MIR_PLATFORM)
    __DRIbuffer           *dri_buffers[__DRI_BUFFER_COUNT];
    struct {
 #ifdef HAVE_WAYLAND_PLATFORM
@@ -205,6 +216,10 @@
    /* EGL-owned buffers */
    __DRIbuffer           *local_buffers[__DRI_BUFFER_COUNT];
 #endif
+
+#ifdef HAVE_MIR_PLATFORM
+   MirMesaEGLNativeSurface *mir_surf;
+#endif
 };
 
 
@@ -266,6 +281,9 @@
 EGLBoolean
 dri2_initialize_android(_EGLDriver *drv, _EGLDisplay *disp);
 
+EGLBoolean
+dri2_initialize_mir(_EGLDriver *drv, _EGLDisplay *disp);
+
 char *
 dri2_get_driver_for_fd(int fd);
 char *
--- /dev/null
+++ b/src/egl/drivers/dri2/platform_mir.c
@@ -0,0 +1,435 @@
+/*
+ * Copyright Â© 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
+ */
+
+#include <mir_toolkit/mesa/native_display.h>
+
+#include "egl_dri2.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+static __DRIbuffer *
+dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
+			     int *width, int *height,
+			     unsigned int *attachments, int count,
+			     int *out_count, void *loaderPrivate)
+{
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+   struct dri2_egl_display *dri2_dpy =
+      dri2_egl_display(dri2_surf->base.Resource.Display);
+   int i;
+
+   dri2_surf->buffer_count = 0;
+   for (i = 0; i < 2*count; i+=2) {
+      assert(attachments[i] < __DRI_BUFFER_COUNT);
+      assert(dri2_surf->buffer_count < 5);
+
+      if (dri2_surf->dri_buffers[attachments[i]] == NULL) {
+         /* Our frame callback must keep these buffers valid */
+         assert(attachments[i] != __DRI_BUFFER_FRONT_LEFT);
+         assert(attachments[i] != __DRI_BUFFER_BACK_LEFT);
+
+         dri2_surf->dri_buffers[attachments[i]] =
+            dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
+                  attachments[i], attachments[i+1],
+                  dri2_surf->base.Width, dri2_surf->base.Height);
+
+         if (!dri2_surf->dri_buffers[attachments[i]])
+            continue;
+      }
+
+      memcpy(&dri2_surf->buffers[dri2_surf->buffer_count],
+             dri2_surf->dri_buffers[attachments[i]],
+             sizeof(__DRIbuffer));
+
+      dri2_surf->buffer_count++;
+   }
+
+   assert(dri2_surf->base.Type == EGL_PIXMAP_BIT ||
+          dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
+
+   *out_count = dri2_surf->buffer_count;
+   if (dri2_surf->buffer_count == 0)
+	   return NULL;
+
+   *width = dri2_surf->base.Width;
+   *height = dri2_surf->base.Height;
+
+   return dri2_surf->buffers;
+}
+
+static __DRIbuffer *
+dri2_get_buffers(__DRIdrawable * driDrawable,
+		 int *width, int *height,
+		 unsigned int *attachments, int count,
+		 int *out_count, void *loaderPrivate)
+{
+   unsigned int *attachments_with_format;
+   __DRIbuffer *buffer;
+   const unsigned int format = 32;
+   int i;
+
+   attachments_with_format = calloc(count * 2, sizeof(unsigned int));
+   if (!attachments_with_format) {
+      *out_count = 0;
+      return NULL;
+   }
+
+   for (i = 0; i < count; ++i) {
+      attachments_with_format[2*i] = attachments[i];
+      attachments_with_format[2*i + 1] = format;
+   }
+
+   buffer =
+      dri2_get_buffers_with_format(driDrawable,
+				   width, height,
+				   attachments_with_format, count,
+				   out_count, loaderPrivate);
+
+   free(attachments_with_format);
+
+   return buffer;
+}
+
+
+static void
+dri2_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
+{
+   (void) driDrawable;
+
+   /* FIXME: Does EGL support front buffer rendering at all? */
+
+#if 0
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+
+   dri2WaitGL(dri2_surf);
+#else
+   (void) loaderPrivate;
+#endif
+}
+
+static EGLBoolean
+mir_advance_colour_buffer(struct dri2_egl_surface *surf)
+{
+   MirBufferPackage buffer_package;
+   if(!surf->mir_surf->surface_advance_buffer(surf->mir_surf, &buffer_package))
+      return EGL_FALSE;
+
+   /* We expect no data items, and (for the moment) one PRIME fd */
+   assert(buffer_package.data_items == 0);
+   assert(buffer_package.fd_items == 1);
+
+   /* Mir ABIs prior to release 0.1.2 lacked width and height */
+   if (buffer_package.width && buffer_package.height) {
+      surf->base.Width = buffer_package.width;
+      surf->base.Height = buffer_package.height;
+   }
+
+   surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]->name = 0;
+   surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]->fd = buffer_package.fd[0];
+   surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]->pitch = buffer_package.stride;
+   return EGL_TRUE;
+}
+
+/**
+ * Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
+ */
+static _EGLSurface *
+dri2_create_mir_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
+                               _EGLConfig *conf, EGLNativeWindowType window,
+                               const EGLint *attrib_list)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
+   struct dri2_egl_surface *dri2_surf;
+   MirSurfaceParameters surf_params;
+
+   (void) drv;
+
+   dri2_surf = calloc(1, sizeof *dri2_surf);
+   if (!dri2_surf) {
+      _eglError(EGL_BAD_ALLOC, "dri2_create_surface");
+      return NULL;
+   }
+
+   if (!_eglInitSurface(&dri2_surf->base, disp, EGL_WINDOW_BIT, conf, attrib_list))
+      goto cleanup_surf;
+
+   dri2_surf->mir_surf = window;
+   if (!dri2_surf->mir_surf->surface_get_parameters(dri2_surf->mir_surf, &surf_params))
+      goto cleanup_surf;
+
+   dri2_surf->base.Width = surf_params.width;
+   dri2_surf->base.Height = surf_params.height;
+
+   dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] =
+      calloc(sizeof(*dri2_surf->dri_buffers[0]), 1);
+   dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT] =
+      calloc(sizeof(*dri2_surf->dri_buffers[0]), 1);
+
+   dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]->attachment =
+      __DRI_BUFFER_BACK_LEFT;
+   /* We only do ARGB 8888 for the moment */
+   dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]->cpp = 4;
+
+   if(!mir_advance_colour_buffer(dri2_surf))
+      goto cleanup_surf;
+
+   if (dri2_dpy->gbm_dri) {
+      struct gbm_dri_surface *surf = malloc(sizeof *surf);
+
+      dri2_surf->gbm_surf = surf;
+      surf->base.gbm = &dri2_dpy->gbm_dri->base;
+      surf->base.width = dri2_surf->base.Width;
+      surf->base.height = dri2_surf->base.Height;
+      surf->base.format = GBM_FORMAT_ARGB8888;
+      surf->base.flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING;
+      surf->dri_private = dri2_surf;
+
+      dri2_surf->dri_drawable =
+          (*dri2_dpy->dri2->createNewDrawable) (dri2_dpy->dri_screen,
+                                                dri2_conf->dri_double_config,
+                                                dri2_surf->gbm_surf);
+   }
+   else {
+      dri2_surf->dri_drawable =
+          (*dri2_dpy->dri2->createNewDrawable) (dri2_dpy->dri_screen,
+                                                dri2_conf->dri_double_config,
+                                                dri2_surf);
+   }
+
+   if (dri2_surf->dri_drawable == NULL) {
+      _eglError(EGL_BAD_ALLOC, "dri2->createNewDrawable");
+   }
+
+   return &dri2_surf->base;
+
+cleanup_surf:
+   free(dri2_surf);
+   return NULL;
+}
+
+static EGLBoolean
+dri2_destroy_mir_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
+   int i;
+
+   (void) drv;
+
+   if (!_eglPutSurface(surf))
+      return EGL_TRUE;
+
+   (*dri2_dpy->core->destroyDrawable)(dri2_surf->dri_drawable);
+
+   for (i = 0; i < __DRI_BUFFER_COUNT; ++i) {
+      if (dri2_surf->dri_buffers[i] && !((i == __DRI_BUFFER_FRONT_LEFT) ||
+                                         (i == __DRI_BUFFER_BACK_LEFT))) {
+         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
+                                       dri2_surf->dri_buffers[i]);
+      }
+   }
+   free(dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT]);
+   free(dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
+
+   free(dri2_surf->gbm_surf);
+   free(surf);
+
+   return EGL_TRUE;
+}
+
+/**
+ * Called via eglSwapInterval(), drv->API.SwapInterval().
+ */
+static EGLBoolean
+dri2_set_swap_interval(_EGLDriver *drv, _EGLDisplay *disp,
+                       _EGLSurface *surf, EGLint interval)
+{
+   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surf);
+   if(!dri2_surf->mir_surf->surface_set_swapinterval(dri2_surf->mir_surf, interval))
+      return EGL_FALSE;
+   return EGL_TRUE;
+}
+
+/**
+ * Called via eglSwapBuffers(), drv->API.SwapBuffers().
+ */
+static EGLBoolean
+dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
+
+   (*dri2_dpy->flush->flush)(dri2_surf->dri_drawable);
+
+   int rc = mir_advance_colour_buffer(dri2_surf);
+
+   (*dri2_dpy->flush->invalidate)(dri2_surf->dri_drawable);
+
+   return rc;
+}
+
+static int
+dri2_mir_authenticate(_EGLDisplay *disp, uint32_t id)
+{
+   return 0;
+}
+
+static _EGLImage *
+dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
+                             EGLClientBuffer buffer, const EGLint *attr_list)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct gbm_dri_bo *dri_bo = gbm_dri_bo((struct gbm_bo *) buffer);
+   struct dri2_egl_image *dri2_img;
+
+   dri2_img = malloc(sizeof *dri2_img);
+   if (!dri2_img) {
+      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr_pixmap");
+      return NULL;
+   }
+
+   if (!_eglInitImage(&dri2_img->base, disp)) {
+      free(dri2_img);
+      return NULL;
+   }
+
+
+   dri2_img->dri_image = dri2_dpy->image->dupImage(dri_bo->image, dri2_img);
+   if (dri2_img->dri_image == NULL) {
+      free(dri2_img);
+      _eglError(EGL_BAD_ALLOC, "dri2_create_image_khr_pixmap");
+      return NULL;
+   }
+
+   return &dri2_img->base;
+}
+
+static _EGLImage *
+dri2_mir_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
+                          _EGLContext *ctx, EGLenum target,
+                          EGLClientBuffer buffer, const EGLint *attr_list)
+{
+   (void) drv;
+
+   switch (target) {
+   case EGL_NATIVE_PIXMAP_KHR:
+      return dri2_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
+   default:
+      return dri2_create_image_khr(drv, disp, ctx, target, buffer, attr_list);
+   }
+}
+
+EGLBoolean
+dri2_initialize_mir(_EGLDriver *drv, _EGLDisplay *disp)
+{
+   struct dri2_egl_display *dri2_dpy;
+   struct gbm_device *gbm = NULL;
+   MirPlatformPackage platform;
+   const __DRIconfig *config;
+   static const unsigned int argb_masks[4] =
+      { 0xff0000, 0xff00, 0xff, 0xff000000 };
+   uint32_t types;
+   int i;
+
+   drv->API.CreateWindowSurface = dri2_create_mir_window_surface;
+   drv->API.DestroySurface = dri2_destroy_mir_surface;
+   drv->API.SwapBuffers = dri2_swap_buffers;
+   drv->API.SwapInterval = dri2_set_swap_interval;
+/*   drv->API.CreatePixmapSurface = dri2_create_pixmap_surface;
+   drv->API.CreatePbufferSurface = dri2_create_pbuffer_surface;
+   drv->API.CopyBuffers = dri2_copy_buffers;
+*/
+   drv->API.CreateImageKHR = dri2_mir_create_image_khr;
+
+   dri2_dpy = calloc(1, sizeof *dri2_dpy);
+   if (!dri2_dpy)
+      return _eglError(EGL_BAD_ALLOC, "eglInitialize");
+
+   disp->DriverData = (void *) dri2_dpy;
+   dri2_dpy->mir_disp = disp->PlatformDisplay;
+   dri2_dpy->mir_disp->display_get_platform(dri2_dpy->mir_disp, &platform);
+   dri2_dpy->fd = platform.fd[0];
+   dri2_dpy->device_name = dri2_get_device_name_for_fd(dri2_dpy->fd);
+
+   /*
+    * At the moment, a pointer to gbm_device is the first and only
+    * information optionally contained in platform.data[].
+    */
+   if (platform.data_items == 0) {
+      dri2_dpy->own_device = 1;
+      dri2_dpy->fd = dup(dri2_dpy->fd);
+      gbm = gbm_create_device(dri2_dpy->fd);
+      if (gbm == NULL)
+         goto cleanup_dpy;
+   }
+   else {
+      gbm = *(struct gbm_device**)platform.data;
+   }
+
+   if (gbm) {
+      struct gbm_dri_device *gbm_dri = gbm_dri_device(gbm);
+
+      dri2_dpy->gbm_dri = gbm_dri;
+      dri2_dpy->driver_name = gbm_dri->base.driver_name;
+      dri2_dpy->dri_screen = gbm_dri->screen;
+      dri2_dpy->core = gbm_dri->core;
+      dri2_dpy->dri2 = gbm_dri->dri2;
+      dri2_dpy->image = gbm_dri->image;
+      dri2_dpy->flush = gbm_dri->flush;
+      dri2_dpy->driver_configs = gbm_dri->driver_configs;
+
+      gbm_dri->lookup_image = dri2_lookup_egl_image;
+      gbm_dri->lookup_user_data = disp;
+
+      gbm_dri->get_buffers = dri2_get_buffers;
+      gbm_dri->flush_front_buffer = dri2_flush_front_buffer;
+      gbm_dri->get_buffers_with_format = dri2_get_buffers_with_format;
+
+      dri2_setup_screen(disp);
+   }
+
+   types = EGL_WINDOW_BIT;
+   for (i = 0; dri2_dpy->driver_configs[i]; i++) {
+      config = dri2_dpy->driver_configs[i];
+      dri2_add_config(disp, config, i + 1, types, NULL, argb_masks);
+   }
+
+   dri2_dpy->authenticate = dri2_mir_authenticate;
+
+   disp->VersionMajor = 1;
+   disp->VersionMinor = 4;
+
+   return EGL_TRUE;
+
+ cleanup_dpy:
+   free(dri2_dpy);
+
+   return EGL_FALSE;
+}
--- a/src/egl/main/Makefile.am
+++ b/src/egl/main/Makefile.am
@@ -102,6 +102,11 @@
 AM_CFLAGS += -DHAVE_NULL_PLATFORM
 endif
 
+if HAVE_EGL_PLATFORM_MIR
+AM_CFLAGS += -DHAVE_MIR_PLATFORM
+AM_CFLAGS += $(MIR_CFLAGS)
+endif
+
 if HAVE_EGL_DRIVER_GLX
 AM_CFLAGS += -D_EGL_BUILT_IN_DRIVER_GLX
 libEGL_la_LIBADD += ../drivers/glx/libegl_glx.la
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -59,7 +59,10 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #endif
-
+#ifdef HAVE_MIR_PLATFORM
+#include <dlfcn.h>
+#include <mir_toolkit/mesa/native_display.h>
+#endif
 
 /**
  * Map --with-egl-platforms names to platform types.
@@ -74,7 +77,8 @@
    { _EGL_PLATFORM_DRM, "drm" },
    { _EGL_PLATFORM_FBDEV, "fbdev" },
    { _EGL_PLATFORM_NULL, "null" },
-   { _EGL_PLATFORM_ANDROID, "android" }
+   { _EGL_PLATFORM_ANDROID, "android" },
+   { _EGL_PLATFORM_MIR, "mir" },
 };
 
 
@@ -134,6 +138,47 @@
 #endif
 }
 
+#ifdef HAVE_MIR_PLATFORM
+static EGLBoolean
+_mir_display_is_valid(EGLNativeDisplayType nativeDisplay)
+{
+   typedef int (*MirEGLNativeDisplayIsValidFunc)(MirMesaEGLNativeDisplay*);
+
+   void *lib;
+   MirEGLNativeDisplayIsValidFunc general_check;
+   MirEGLNativeDisplayIsValidFunc client_check;
+   MirEGLNativeDisplayIsValidFunc server_check;
+   EGLBoolean is_valid = EGL_FALSE;
+
+   lib = dlopen(NULL, RTLD_LAZY);
+   if (lib == NULL)
+      return EGL_FALSE;
+
+   general_check = (MirEGLNativeDisplayIsValidFunc) dlsym(lib, "mir_egl_mesa_display_is_valid");
+   client_check = (MirEGLNativeDisplayIsValidFunc) dlsym(lib, "mir_client_mesa_egl_native_display_is_valid");
+   server_check = (MirEGLNativeDisplayIsValidFunc) dlsym(lib, "mir_server_mesa_egl_native_display_is_valid");
+
+   if (general_check != NULL &&
+       general_check((MirMesaEGLNativeDisplay *)nativeDisplay))
+   {
+      is_valid = EGL_TRUE;
+   }
+   else if (client_check != NULL &&
+            client_check((MirMesaEGLNativeDisplay *)nativeDisplay))
+   {
+      is_valid = EGL_TRUE;
+   }
+   else if (server_check != NULL &&
+            server_check((MirMesaEGLNativeDisplay *)nativeDisplay))
+   {
+      is_valid = EGL_TRUE;
+   }
+
+   dlclose(lib);
+
+   return is_valid;
+}
+#endif
 
 /**
  * Try detecting native platform with the help of native display characteristcs.
@@ -154,6 +199,11 @@
       return _EGL_PLATFORM_FBDEV;
 #endif
 
+#ifdef HAVE_MIR_PLATFORM
+   if (_mir_display_is_valid(nativeDisplay))
+      return _EGL_PLATFORM_MIR;
+#endif
+
    if (_eglPointerIsDereferencable(nativeDisplay)) {
       void *first_pointer = *(void **) nativeDisplay;
 
@@ -188,7 +238,7 @@
 _EGLPlatformType
 _eglGetNativePlatform(EGLNativeDisplayType nativeDisplay)
 {
-   static _EGLPlatformType native_platform = _EGL_INVALID_PLATFORM;
+   _EGLPlatformType native_platform = _EGL_INVALID_PLATFORM;
    char *detection_method = NULL;
 
    if (native_platform == _EGL_INVALID_PLATFORM) {
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -46,6 +46,7 @@
    _EGL_PLATFORM_FBDEV,
    _EGL_PLATFORM_NULL,
    _EGL_PLATFORM_ANDROID,
+   _EGL_PLATFORM_MIR,
 
    _EGL_NUM_PLATFORMS,
    _EGL_INVALID_PLATFORM = -1
--- a/src/egl/main/egldriver.c
+++ b/src/egl/main/egldriver.c
@@ -57,7 +57,7 @@
    char *Path;
    _EGLMain_t BuiltIn;
    void *Handle;
-   _EGLDriver *Driver;
+   _EGLDriver *Driver[_EGL_NUM_PLATFORMS];
 } _EGLModule;
 
 static _EGL_DECLARE_MUTEX(_eglModuleMutex);
@@ -134,7 +134,6 @@
 
 #endif
 
-
 /**
  * Open the named driver and find its bootstrap function: _eglMain().
  */
@@ -147,8 +146,12 @@
 
    assert(driverPath);
 
-   _eglLog(_EGL_DEBUG, "dlopen(%s)", driverPath);
-   lib = open_library(driverPath);
+   if (*handle) {
+      lib = *handle;
+   } else {
+      _eglLog(_EGL_DEBUG, "dlopen(%s)", driverPath);
+      lib = open_library(driverPath);
+   }
 
 #if defined(_EGL_OS_WINDOWS)
    /* XXX untested */
@@ -194,13 +197,13 @@
  * Load a module and create the driver object.
  */
 static EGLBoolean
-_eglLoadModule(_EGLModule *mod)
+_eglLoadModule(_EGLModule *mod, _EGLPlatformType plat)
 {
    _EGLMain_t mainFunc;
-   lib_handle lib;
+   lib_handle lib = (lib_handle) mod->Handle;
    _EGLDriver *drv;
 
-   if (mod->Driver)
+   if (mod->Driver[plat])
       return EGL_TRUE;
 
    if (mod->BuiltIn) {
@@ -226,7 +229,7 @@
    }
 
    mod->Handle = (void *) lib;
-   mod->Driver = drv;
+   mod->Driver[plat] = drv;
 
    return EGL_TRUE;
 }
@@ -240,8 +243,10 @@
 {
 #if defined(_EGL_OS_UNIX)
    /* destroy the driver */
-   if (mod->Driver && mod->Driver->Unload)
-      mod->Driver->Unload(mod->Driver);
+   for (int plat = 0; plat < _EGL_NUM_PLATFORMS; ++plat) {
+      if (mod->Driver[plat] && mod->Driver[plat]->Unload)
+         mod->Driver[plat]->Unload(mod->Driver[plat]);
+   }
 
    /*
     * XXX At this point (atexit), the module might be the last reference to
@@ -255,7 +260,9 @@
    /* XXX Windows unloads DLLs before atexit */
 #endif
 
-   mod->Driver = NULL;
+   for (int plat = 0; plat < _EGL_NUM_PLATFORMS; ++plat) {
+      mod->Driver[plat] = NULL;
+   }
    mod->Handle = NULL;
 }
 
@@ -599,17 +606,17 @@
    while (i < _eglModules->Size) {
       _EGLModule *mod = (_EGLModule *) _eglModules->Elements[i];
 
-      if (!_eglLoadModule(mod)) {
+      if (!_eglLoadModule(mod, dpy->Platform)) {
          /* remove invalid modules */
          _eglEraseArray(_eglModules, i, _eglFreeModule);
          continue;
       }
 
-      if (mod->Driver->API.Initialize(mod->Driver, dpy)) {
-         drv = mod->Driver;
+      drv = mod->Driver[dpy->Platform];
+      if (drv->API.Initialize(drv, dpy))
          break;
-      }
       else {
+         drv = NULL;
          i++;
       }
    }
@@ -661,7 +668,6 @@
 _eglGetDriverProc(const char *procname)
 {
    EGLint i;
-   _EGLProc proc = NULL;
 
    if (!_eglModules) {
       /* load the driver for the default display */
@@ -673,15 +679,18 @@
 
    for (i = 0; i < _eglModules->Size; i++) {
       _EGLModule *mod = (_EGLModule *) _eglModules->Elements[i];
+      _EGLProc proc;
 
-      if (!mod->Driver)
-         break;
-      proc = mod->Driver->API.GetProcAddress(mod->Driver, procname);
-      if (proc)
-         break;
+      for (_EGLPlatformType plat = 0; plat < _EGL_NUM_PLATFORMS; ++plat) {
+         if (!mod->Driver[plat])
+            continue;
+         proc = mod->Driver[plat]->API.GetProcAddress(mod->Driver[plat], procname);
+         if (proc)
+            return proc;
+      }
    }
 
-   return proc;
+   return NULL;
 }
 
 
--- a/src/gallium/drivers/freedreno/freedreno_screen.c
+++ b/src/gallium/drivers/freedreno/freedreno_screen.c
@@ -359,6 +359,11 @@
 	struct fd_screen *screen = fd_screen(pscreen);
 	struct fd_bo *bo;
 
+	if (whandle->type != DRM_API_HANDLE_TYPE_SHARED) {
+		DBG("Attempt to import unsupported handle type %d", whandle->type);
+		return NULL;
+	}
+
 	bo = fd_bo_from_name(screen->dev, whandle->handle);
 	if (!bo) {
 		DBG("ref name 0x%08x failed", whandle->handle);
--- a/src/gallium/drivers/nouveau/nouveau_screen.c
+++ b/src/gallium/drivers/nouveau/nouveau_screen.c
@@ -85,8 +85,19 @@
 	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
 	struct nouveau_bo *bo = 0;
 	int ret;
+ 
+	if (whandle->type != DRM_API_HANDLE_TYPE_SHARED &&
+	    whandle->type != DRM_API_HANDLE_TYPE_FD) {
+		debug_printf("%s: attempt to import unsupported handle type %d\n",
+			     __FUNCTION__, whandle->type);
+		return NULL;		
+	}
+
+	if (whandle->type == DRM_API_HANDLE_TYPE_SHARED)
+		ret = nouveau_bo_name_ref(dev, whandle->handle, &bo);
+	else
+		ret = nouveau_bo_prime_handle_ref(dev, whandle->handle, &bo);
 
-	ret = nouveau_bo_name_ref(dev, whandle->handle, &bo);
 	if (ret) {
 		debug_printf("%s: ref name 0x%08x failed with %d\n",
 			     __FUNCTION__, whandle->handle, ret);
@@ -111,6 +122,8 @@
 	} else if (whandle->type == DRM_API_HANDLE_TYPE_KMS) {
 		whandle->handle = bo->handle;
 		return TRUE;
+	} else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
+		return nouveau_bo_set_prime(bo, &whandle->handle) == 0;
 	} else {
 		return FALSE;
 	}
--- a/src/gallium/include/state_tracker/drm_driver.h
+++ b/src/gallium/include/state_tracker/drm_driver.h
@@ -10,6 +10,8 @@
 
 #define DRM_API_HANDLE_TYPE_SHARED 0
 #define DRM_API_HANDLE_TYPE_KMS    1
+#define DRM_API_HANDLE_TYPE_FD     2
+
 
 /**
  * For use with pipe_screen::{texture_from_handle|texture_get_handle}.
@@ -17,9 +19,10 @@
 struct winsys_handle
 {
    /**
-    * Unused for texture_from_handle, always
-    * DRM_API_HANDLE_TYPE_SHARED.  Input to texture_get_handle,
-    * use TEXTURE_USAGE to select handle for kms or ipc.
+    * Input for texture_from_handle, valid values are
+    * DRM_API_HANDLE_TYPE_SHARED or DRM_API_HANDLE_TYPE_FD.
+    * Input to texture_get_handle,
+    * to select handle for kms, flink, or prime.
     */
    unsigned type;
    /**
@@ -42,6 +45,8 @@
 enum drm_conf {
    /* How many frames to allow before throttling. Or -1 to indicate any number */
    DRM_CONF_THROTTLE, /* DRM_CONF_INT. */
+   /* Can this driver, running on this kernel, import and export dma-buf fds? */
+   DRM_CONF_SHARE_FD, /* DRM_CONF_BOOL. */
    DRM_CONF_MAX
 };
 
--- a/src/gallium/state_trackers/dri/drm/dri2.c
+++ b/src/gallium/state_trackers/dri/drm/dri2.c
@@ -33,6 +33,9 @@
 #include "util/u_format.h"
 #include "util/u_debug.h"
 #include "state_tracker/drm_driver.h"
+#include "state_tracker/st_texture.h"
+#include "state_tracker/st_context.h"
+#include "main/texobj.h"
 
 #include "dri_screen.h"
 #include "dri_context.h"
@@ -262,7 +265,13 @@
 
       templ.format = format;
       templ.bind = bind;
-      whandle.handle = buf->name;
+      if (buf->name != 0) {
+         whandle.type = DRM_API_HANDLE_TYPE_SHARED;
+         whandle.handle = buf->name;
+      } else {
+         whandle.type = DRM_API_HANDLE_TYPE_FD;
+         whandle.handle = buf->fd;
+      }
       whandle.stride = buf->pitch;
 
       drawable->textures[statt] =
@@ -526,14 +535,14 @@
 }
 
 static __DRIimage *
-dri2_create_image_from_name(__DRIscreen *_screen,
-                            int width, int height, int format,
-                            int name, int pitch, void *loaderPrivate)
+dri2_create_image_from_winsys(__DRIscreen *_screen,
+                              int width, int height, int format,
+                              struct winsys_handle *whandle, int pitch,
+                              void *loaderPrivate)
 {
    struct dri_screen *screen = dri_screen(_screen);
    __DRIimage *img;
    struct pipe_resource templ;
-   struct winsys_handle whandle;
    unsigned tex_usage;
    enum pipe_format pf;
 
@@ -573,12 +582,10 @@
    templ.depth0 = 1;
    templ.array_size = 1;
 
-   memset(&whandle, 0, sizeof(whandle));
-   whandle.handle = name;
-   whandle.stride = pitch * util_format_get_blocksize(pf);
+   whandle->stride = pitch * util_format_get_blocksize(pf);
 
    img->texture = screen->base.screen->resource_from_handle(screen->base.screen,
-         &templ, &whandle);
+         &templ, whandle);
    if (!img->texture) {
       FREE(img);
       return NULL;
@@ -593,6 +600,39 @@
 }
 
 static __DRIimage *
+dri2_create_image_from_name(__DRIscreen *_screen,
+                            int width, int height, int format,
+                            int name, int pitch, void *loaderPrivate)
+{
+   struct winsys_handle whandle;
+
+   memset(&whandle, 0, sizeof(whandle));
+   whandle.type = DRM_API_HANDLE_TYPE_SHARED;
+   whandle.handle = name;
+
+   return dri2_create_image_from_winsys(_screen, width, height, format,
+                                        &whandle, pitch, loaderPrivate);
+}
+
+static __DRIimage *
+dri2_create_image_from_fd(__DRIscreen *_screen,
+                          int width, int height, int format,
+                          int fd, int pitch, void *loaderPrivate)
+{
+   struct winsys_handle whandle;
+
+   if (fd < 0)
+      return NULL;
+
+   memset(&whandle, 0, sizeof(whandle));
+   whandle.type = DRM_API_HANDLE_TYPE_FD;
+   whandle.handle = (unsigned)fd;
+
+   return dri2_create_image_from_winsys(_screen, width, height, format,
+                                        &whandle, pitch, loaderPrivate);
+}
+
+static __DRIimage *
 dri2_create_image_from_renderbuffer(__DRIcontext *context,
 				    int renderbuffer, void *loaderPrivate)
 {
@@ -686,6 +726,7 @@
 
    switch (attrib) {
    case __DRI_IMAGE_ATTRIB_STRIDE:
+      whandle.type = DRM_API_HANDLE_TYPE_KMS;
       image->texture->screen->resource_get_handle(image->texture->screen,
             image->texture, &whandle);
       *value = whandle.stride;
@@ -702,6 +743,12 @@
          image->texture, &whandle);
       *value = whandle.handle;
       return GL_TRUE;
+   case __DRI_IMAGE_ATTRIB_FD:
+      whandle.type= DRM_API_HANDLE_TYPE_FD;
+      image->texture->screen->resource_get_handle(image->texture->screen,
+         image->texture, &whandle);
+      *value = whandle.handle;
+      return GL_TRUE;
    case __DRI_IMAGE_ATTRIB_FORMAT:
       *value = image->dri_format;
       return GL_TRUE;
@@ -825,6 +872,122 @@
    return img;
 }
 
+static __DRIimage *
+dri2_create_from_texture(__DRIcontext *context, int target, unsigned texture,
+                         int depth, int level, unsigned *error,
+                         void *loaderPrivate)
+{
+   __DRIimage *img;
+   struct gl_context *ctx = ((struct st_context *)dri_context(context)->st)->ctx;
+   struct gl_texture_object *obj;
+   struct pipe_resource *tex;
+   GLuint face = 0;
+
+   obj = _mesa_lookup_texture(ctx, texture);
+   if (!obj || obj->Target != target) {
+      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   tex = st_get_texobj_resource(obj);
+   if (!tex) {
+      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   if (target == GL_TEXTURE_CUBE_MAP)
+      face = depth;
+
+   _mesa_test_texobj_completeness(ctx, obj);
+   if (!obj->_BaseComplete || (level > 0 && !obj->_MipmapComplete)) {
+      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   if (level < obj->BaseLevel || level > obj->_MaxLevel) {
+      *error = __DRI_IMAGE_ERROR_BAD_MATCH;
+      return NULL;
+   }
+
+   if (target == GL_TEXTURE_3D && obj->Image[face][level]->Depth < depth) {
+      *error = __DRI_IMAGE_ERROR_BAD_MATCH;
+      return NULL;
+   }
+
+   img = CALLOC_STRUCT(__DRIimageRec);
+   if (!img) {
+      *error = __DRI_IMAGE_ERROR_BAD_ALLOC;
+      return NULL;
+   }
+
+   img->level = level;
+   img->layer = depth;
+   img->dri_format = driGLFormatToImageFormat(obj->Image[face][level]->TexFormat);
+
+   img->loader_private = loaderPrivate;
+
+   if (img->dri_format == __DRI_IMAGE_FORMAT_NONE) {
+      *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
+      free(img);
+      return NULL;
+   }
+
+   pipe_resource_reference(&img->texture, tex);
+
+   *error = __DRI_IMAGE_ERROR_SUCCESS;
+   return img;
+}
+
+static __DRIimage *
+dri2_from_fds(__DRIscreen *screen, int width, int height, int fourcc,
+              int *fds, int num_fds, int *strides, int *offsets,
+              void *loaderPrivate)
+{
+   __DRIimage *img;
+   int format, stride, dri_components;
+
+   if (num_fds != 1)
+      return NULL;
+   if (offsets[0] != 0)
+      return NULL;
+
+   switch(fourcc) {
+   case __DRI_IMAGE_FOURCC_RGB565:
+      format = __DRI_IMAGE_FORMAT_RGB565;
+      dri_components = __DRI_IMAGE_COMPONENTS_RGB;
+      break;
+   case __DRI_IMAGE_FOURCC_ARGB8888:
+      format = __DRI_IMAGE_FORMAT_ARGB8888;
+      dri_components = __DRI_IMAGE_COMPONENTS_RGBA;
+      break;
+   case __DRI_IMAGE_FOURCC_XRGB8888:
+      format = __DRI_IMAGE_FORMAT_XRGB8888;
+      dri_components = __DRI_IMAGE_COMPONENTS_RGB;
+      break;
+   case __DRI_IMAGE_FOURCC_ABGR8888:
+      format = __DRI_IMAGE_FORMAT_ABGR8888;
+      dri_components = __DRI_IMAGE_COMPONENTS_RGBA;
+      break;
+   case __DRI_IMAGE_FOURCC_XBGR8888:
+      format = __DRI_IMAGE_FORMAT_XBGR8888;
+      dri_components = __DRI_IMAGE_COMPONENTS_RGB;
+      break;
+   default:
+      return NULL;
+   }
+
+   /* Strides are in bytes not pixels. */
+   stride = strides[0] /4;
+
+   img = dri2_create_image_from_fd(screen, width, height, format,
+                                   fds[0], stride, loaderPrivate);
+   if (img == NULL)
+      return NULL;
+
+   img->dri_components = dri_components;
+   return img;
+}
+
 static void
 dri2_destroy_image(__DRIimage *img)
 {
@@ -833,7 +996,7 @@
 }
 
 static struct __DRIimageExtensionRec dri2ImageExtension = {
-    { __DRI_IMAGE, 5 },
+    { __DRI_IMAGE, 6 },
     dri2_create_image_from_name,
     dri2_create_image_from_renderbuffer,
     dri2_destroy_image,
@@ -843,6 +1006,7 @@
     dri2_validate_usage,
     dri2_from_names,
     dri2_from_planar,
+    dri2_create_from_texture,
 };
 
 /*
@@ -870,6 +1034,7 @@
    struct dri_screen *screen;
    struct pipe_screen *pscreen;
    const struct drm_conf_ret *throttle_ret = NULL;
+   const struct drm_conf_ret *dmabuf_ret = NULL;
 
    screen = CALLOC_STRUCT(dri_screen);
    if (!screen)
@@ -881,14 +1046,21 @@
    sPriv->driverPrivate = (void *)screen;
 
    pscreen = driver_descriptor.create_screen(screen->fd);
-   if (driver_descriptor.configuration)
+   if (driver_descriptor.configuration) {
       throttle_ret = driver_descriptor.configuration(DRM_CONF_THROTTLE);
+      dmabuf_ret = driver_descriptor.configuration(DRM_CONF_SHARE_FD);
+   }
 
    if (throttle_ret && throttle_ret->val.val_int != -1) {
       screen->throttling_enabled = TRUE;
       screen->default_throttle_frames = throttle_ret->val.val_int;
    }
 
+   if (dmabuf_ret && dmabuf_ret->val.val_bool) {
+      dri2ImageExtension.base.version = 7;
+      dri2ImageExtension.createImageFromFds = dri2_from_fds;
+   }
+
    sPriv->extensions = dri_screen_extensions;
 
    /* dri_init_screen_helper checks pscreen for us */
--- a/src/gallium/state_trackers/egl/common/native_helper.c
+++ b/src/gallium/state_trackers/egl/common/native_helper.c
@@ -427,6 +427,7 @@
 
          memset(&wsh, 0, sizeof(wsh));
          wsh.handle = nbuf->u.drm.name;
+         wsh.type = DRM_API_HANDLE_TYPE_SHARED;
          wsh.stride = nbuf->u.drm.stride;
 
          res = screen->resource_from_handle(screen, &nbuf->u.drm.templ, &wsh);
--- a/src/gallium/state_trackers/egl/x11/native_dri2.c
+++ b/src/gallium/state_trackers/egl/x11/native_dri2.c
@@ -173,6 +173,7 @@
       }
 
       memset(&whandle, 0, sizeof(whandle));
+      whandle.type = DRM_API_HANDLE_TYPE_SHARED;
       whandle.stride = xbuf->pitch;
       whandle.handle = xbuf->name;
       dri2surf->textures[natt] = dri2dpy->base.screen->resource_from_handle(
--- a/src/gallium/targets/dri-ilo/target.c
+++ b/src/gallium/targets/dri-ilo/target.c
@@ -24,4 +24,21 @@
    return screen;
 }
 
-DRM_DRIVER_DESCRIPTOR("i965", "i915", create_screen, NULL)
+
+static const struct drm_conf_ret share_fd_ret = {
+   .type = DRM_CONF_BOOL,
+   .val.val_int = true,
+};
+
+static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
+{
+   switch (conf) {
+   case DRM_CONF_SHARE_FD:
+      return &share_fd_ret;
+   default:
+      break;
+   }
+   return NULL;
+}
+
+DRM_DRIVER_DESCRIPTOR("i965", "i915", create_screen, drm_configuration)
--- a/src/gallium/targets/dri-nouveau/target.c
+++ b/src/gallium/targets/dri-nouveau/target.c
@@ -17,4 +17,20 @@
    return screen;
 }
 
-DRM_DRIVER_DESCRIPTOR("nouveau", "nouveau", create_screen, NULL)
+static const struct drm_conf_ret share_fd_ret = {
+   .type = DRM_CONF_BOOL,
+   .val.val_int = true,
+};
+
+static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
+{
+   switch (conf) {
+   case DRM_CONF_SHARE_FD:
+      return &share_fd_ret;
+   default:
+      break;
+   }
+   return NULL;
+}
+
+DRM_DRIVER_DESCRIPTOR("nouveau", "nouveau", create_screen, drm_configuration)
--- a/src/gallium/targets/dri-vmwgfx/target.c
+++ b/src/gallium/targets/dri-vmwgfx/target.c
@@ -31,11 +31,24 @@
    .val.val_int = 2,
 };
 
+/* Technically this requires kernel support that is not yet
+ * widespread.
+ *
+ * We could check for support in create_screen and return the correct
+ * value, but for now just return true in all cases.
+ */
+static const struct drm_conf_ret share_fd_ret = {
+   .type = DRM_CONF_BOOL,
+   .val.val_int = true,
+};
+
 static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
 {
    switch (conf) {
    case DRM_CONF_THROTTLE:
       return &throttle_ret;
+   case DRM_CONF_SHARE_FD:
+      return &share_fd_ret;
    default:
       break;
    }
--- a/src/gallium/winsys/i915/drm/i915_drm_buffer.c
+++ b/src/gallium/winsys/i915/drm/i915_drm_buffer.c
@@ -95,9 +95,13 @@
                             unsigned *stride)
 {
    struct i915_drm_winsys *idws = i915_drm_winsys(iws);
-   struct i915_drm_buffer *buf = CALLOC_STRUCT(i915_drm_buffer);
+   struct i915_drm_buffer *buf;
    uint32_t tile = 0, swizzle = 0;
 
+   if (whandle->type != DRM_API_HANDLE_TYPE_SHARED)
+      return NULL;
+
+   buf = CALLOC_STRUCT(i915_drm_buffer);
    if (!buf)
       return NULL;
 
--- a/src/gallium/winsys/intel/drm/intel_drm_winsys.c
+++ b/src/gallium/winsys/intel/drm/intel_drm_winsys.c
@@ -257,7 +257,6 @@
                name, gem_name);
       }
       break;
-#if 0
    case DRM_API_HANDLE_TYPE_FD:
       {
          const int fd = (int) handle->handle;
@@ -265,7 +264,6 @@
                fd, height * handle->stride);
       }
       break;
-#endif
    default:
       bo = NULL;
       break;
--- a/src/gallium/winsys/radeon/drm/radeon_drm_bo.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_bo.c
@@ -40,6 +40,7 @@
 #include <sys/ioctl.h>
 #include <xf86drm.h>
 #include <errno.h>
+#include <fcntl.h>
 
 /*
  * this are copy from radeon_drm, once an updated libdrm is released
@@ -114,7 +115,9 @@
     /* Winsys. */
     struct radeon_drm_winsys *rws;
 
-    /* List of buffer handles and its mutex. */
+    /* List of buffer GEM names. Protected by bo_handles_mutex. */
+    struct util_hash_table *bo_names;
+    /* List of buffer handles. Protectded by bo_handles_mutex. */
     struct util_hash_table *bo_handles;
     pipe_mutex bo_handles_mutex;
     pipe_mutex bo_va_mutex;
@@ -370,12 +373,13 @@
 
     memset(&args, 0, sizeof(args));
 
+    pipe_mutex_lock(bo->mgr->bo_handles_mutex);
+    util_hash_table_remove(bo->mgr->bo_handles, (void*)(uintptr_t)bo->handle);
     if (bo->name) {
-        pipe_mutex_lock(bo->mgr->bo_handles_mutex);
-        util_hash_table_remove(bo->mgr->bo_handles,
+        util_hash_table_remove(bo->mgr->bo_names,
                                (void*)(uintptr_t)bo->name);
-        pipe_mutex_unlock(bo->mgr->bo_handles_mutex);
     }
+    pipe_mutex_unlock(bo->mgr->bo_handles_mutex);
 
     if (bo->ptr)
         os_munmap(bo->ptr, bo->base.size);
@@ -660,6 +664,7 @@
 static void radeon_bomgr_destroy(struct pb_manager *_mgr)
 {
     struct radeon_bomgr *mgr = radeon_bomgr(_mgr);
+    util_hash_table_destroy(mgr->bo_names);
     util_hash_table_destroy(mgr->bo_handles);
     pipe_mutex_destroy(mgr->bo_handles_mutex);
     pipe_mutex_destroy(mgr->bo_va_mutex);
@@ -692,6 +697,7 @@
     mgr->base.is_buffer_busy = radeon_bomgr_is_buffer_busy;
 
     mgr->rws = rws;
+    mgr->bo_names = util_hash_table_create(handle_hash, handle_compare);
     mgr->bo_handles = util_hash_table_create(handle_hash, handle_compare);
     pipe_mutex_init(mgr->bo_handles_mutex);
     pipe_mutex_init(mgr->bo_va_mutex);
@@ -841,6 +847,7 @@
                         enum radeon_bo_domain domain)
 {
     struct radeon_drm_winsys *ws = radeon_drm_winsys(rws);
+    struct radeon_bomgr *mgr = radeon_bomgr(ws->kman);
     struct radeon_bo_desc desc;
     struct pb_manager *provider;
     struct pb_buffer *buffer;
@@ -862,6 +869,10 @@
     if (!buffer)
         return NULL;
 
+    pipe_mutex_lock(mgr->bo_handles_mutex);
+    util_hash_table_set(mgr->bo_handles, (void*)(uintptr_t)get_radeon_bo(buffer)->handle, buffer);
+    pipe_mutex_unlock(mgr->bo_handles_mutex);
+
     return (struct pb_buffer*)buffer;
 }
 
@@ -872,10 +883,10 @@
     struct radeon_drm_winsys *ws = radeon_drm_winsys(rws);
     struct radeon_bo *bo;
     struct radeon_bomgr *mgr = radeon_bomgr(ws->kman);
-    struct drm_gem_open open_arg = {};
+    struct drm_radeon_gem_busy args;
     int r;
-
-    memset(&open_arg, 0, sizeof(open_arg));
+    unsigned handle;
+    uint64_t size;
 
     /* We must maintain a list of pairs <handle, bo>, so that we always return
      * the same BO for one particular handle. If we didn't do that and created
@@ -885,8 +896,20 @@
      * The list of pairs is guarded by a mutex, of course. */
     pipe_mutex_lock(mgr->bo_handles_mutex);
 
-    /* First check if there already is an existing bo for the handle. */
-    bo = util_hash_table_get(mgr->bo_handles, (void*)(uintptr_t)whandle->handle);
+    if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
+        /* First check if there already is an existing bo for the handle. */
+        bo = util_hash_table_get(mgr->bo_names, (void*)(uintptr_t)whandle->handle);
+    } else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
+        /* We must first get the GEM handle, as fds are unreliable keys */
+        r = drmPrimeFDToHandle(ws->fd, whandle->handle, &handle);
+        if (r)
+            goto fail;
+        bo = util_hash_table_get(mgr->bo_handles, (void*)(uintptr_t)handle);
+    } else {
+        /* Unknown handle type */
+        goto fail;
+    }
+
     if (bo) {
         /* Increase the refcount. */
         struct pb_buffer *b = NULL;
@@ -900,27 +923,48 @@
         goto fail;
     }
 
-    /* Open the BO. */
-    open_arg.name = whandle->handle;
-    if (drmIoctl(ws->fd, DRM_IOCTL_GEM_OPEN, &open_arg)) {
-        FREE(bo);
-        goto fail;
+    if (whandle->type == DRM_API_HANDLE_TYPE_SHARED) {
+        struct drm_gem_open open_arg = {};
+        memset(&open_arg, 0, sizeof(open_arg));
+        /* Open the BO. */
+        open_arg.name = whandle->handle;
+        if (drmIoctl(ws->fd, DRM_IOCTL_GEM_OPEN, &open_arg)) {
+            FREE(bo);
+            goto fail;
+        }
+        handle = open_arg.handle;
+        size = open_arg.size;
+        bo->name = whandle->handle;
+    } else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
+        size = lseek(whandle->handle, 0, SEEK_END);
+        /* 
+         * Could check errno to determine whether the kernel is new enough, but
+         * it doesn't really matter why this failed, just that it failed.
+         */
+        if (size == (off_t)-1) {
+            FREE(bo);
+            goto fail;
+        }
+        lseek(whandle->handle, 0, SEEK_SET);
     }
-    bo->handle = open_arg.handle;
-    bo->name = whandle->handle;
+
+    bo->handle = handle;
 
     /* Initialize it. */
     pipe_reference_init(&bo->base.reference, 1);
     bo->base.alignment = 0;
     bo->base.usage = PB_USAGE_GPU_WRITE | PB_USAGE_GPU_READ;
-    bo->base.size = open_arg.size;
+    bo->base.size = (unsigned) size;
     bo->base.vtbl = &radeon_bo_vtbl;
     bo->mgr = mgr;
     bo->rws = mgr->rws;
     bo->va = 0;
     pipe_mutex_init(bo->map_mutex);
 
-    util_hash_table_set(mgr->bo_handles, (void*)(uintptr_t)whandle->handle, bo);
+    if (bo->name)
+        util_hash_table_set(mgr->bo_names, (void*)(uintptr_t)bo->name, bo);
+
+    util_hash_table_set(mgr->bo_handles, (void*)(uintptr_t)bo->handle, bo);
 
 done:
     pipe_mutex_unlock(mgr->bo_handles_mutex);
@@ -931,7 +975,7 @@
     if (mgr->va && !bo->va) {
         struct drm_radeon_gem_va va;
 
-        bo->va_size = ((bo->base.size + 4095) & ~4095);
+        bo->va_size = ((size + 4095) & ~4095);
         bo->va = radeon_bomgr_find_va(mgr, bo->va_size, 1 << 20);
 
         va.handle = bo->handle;
@@ -955,8 +999,27 @@
         }
     }
 
-    ws->allocated_vram += align(open_arg.size, 4096);
-    bo->initial_domain = RADEON_DOMAIN_VRAM;
+    memset(&args, 0, sizeof(args));
+
+    args.handle = bo->handle;
+    r = drmCommandWriteRead(bo->rws->fd, DRM_RADEON_GEM_BUSY, &args, sizeof(args));
+    /* We don't mind if the bo is busy; we're just after the memory domain */
+    if (r && r != -EBUSY) {
+        fprintf(stderr, "radeon: Failed to find initial domain for imported bo\n");
+        radeon_bo_destroy(&bo->base);
+        return NULL;
+    }
+    bo->initial_domain = args.domain;
+
+    switch (bo->initial_domain) {
+    case RADEON_DOMAIN_GTT:
+        ws->allocated_gtt += align(size, 4096);
+        break;
+    case RADEON_DOMAIN_VRAM:
+        ws->allocated_vram += align(size, 4096);
+        break;
+    }
+
 
     return (struct pb_buffer*)bo;
 
@@ -986,12 +1049,15 @@
             bo->flink = flink.name;
 
             pipe_mutex_lock(bo->mgr->bo_handles_mutex);
-            util_hash_table_set(bo->mgr->bo_handles, (void*)(uintptr_t)bo->flink, bo);
+            util_hash_table_set(bo->mgr->bo_names, (void*)(uintptr_t)bo->flink, bo);
             pipe_mutex_unlock(bo->mgr->bo_handles_mutex);
         }
         whandle->handle = bo->flink;
     } else if (whandle->type == DRM_API_HANDLE_TYPE_KMS) {
         whandle->handle = bo->handle;
+    } else if (whandle->type == DRM_API_HANDLE_TYPE_FD) {
+        if (drmPrimeHandleToFD(bo->rws->fd, bo->handle, DRM_CLOEXEC, (int*)&whandle->handle))
+            return FALSE;
     }
 
     whandle->stride = stride;
--- a/src/gallium/winsys/svga/drm/vmw_screen_dri.c
+++ b/src/gallium/winsys/svga/drm/vmw_screen_dri.c
@@ -40,6 +40,7 @@
 #include <xf86drm.h>
 
 #include <stdio.h>
+#include <fcntl.h>
 
 struct dri1_api_version {
    int major;
@@ -160,31 +161,57 @@
     union drm_vmw_surface_reference_arg arg;
     struct drm_vmw_surface_arg *req = &arg.req;
     struct drm_vmw_surface_create_req *rep = &arg.rep;
+    uint32_t handle = 0;
     int ret;
     int i;
 
-    /**
-     * The vmware device specific handle is the hardware SID.
-     * FIXME: We probably want to move this to the ioctl implementations.
-     */
+    switch (whandle->type) {
+    case DRM_API_HANDLE_TYPE_SHARED:
+    case DRM_API_HANDLE_TYPE_KMS:
+       handle = whandle->handle;
+       break;
+    case DRM_API_HANDLE_TYPE_FD:
+       ret = drmPrimeFDToHandle(vws->ioctl.drm_fd, whandle->handle,
+                                &handle);
+       if (ret) {
+	  vmw_error("Failed to get handle from prime fd %d.\n",
+		    (int) whandle->handle);
+	  return NULL;
+       }
+       break;
+    default:
+       vmw_error("Attempt to import unsupported handle type %d.\n",
+                 whandle->type);
+       return NULL;
+    }
 
     memset(&arg, 0, sizeof(arg));
-    req->sid = whandle->handle;
+    req->sid = handle;
 
     ret = drmCommandWriteRead(vws->ioctl.drm_fd, DRM_VMW_REF_SURFACE,
 			      &arg, sizeof(arg));
 
+    /*
+     * Need to close the handle we got from prime.
+     */
+    if (whandle->type == DRM_API_HANDLE_TYPE_FD)
+       vmw_ioctl_surface_destroy(vws, handle);
+
     if (ret) {
-        vmw_error("Failed referencing shared surface. SID %d.\n"
-                  "Error %d (%s).\n",
-                  whandle->handle, ret, strerror(-ret));
-	return NULL;
+       /*
+        * Any attempt to share something other than a surface, like a dumb
+        * kms buffer, should fail here.
+        */
+       vmw_error("Failed referencing shared surface. SID %d.\n"
+                 "Error %d (%s).\n",
+                 handle, ret, strerror(-ret));
+       return NULL;
     }
 
     if (rep->mip_levels[0] != 1) {
         vmw_error("Incorrect number of mipmap levels on shared surface."
                   " SID %d, levels %d\n",
-                  whandle->handle, rep->mip_levels[0]);
+                  handle, rep->mip_levels[0]);
 	goto out_mip;
     }
 
@@ -192,7 +219,7 @@
 	if (rep->mip_levels[i] != 0) {
             vmw_error("Incorrect number of faces levels on shared surface."
                       " SID %d, face %d present.\n",
-                      whandle->handle, i);
+                      handle, i);
 	    goto out_mip;
 	}
    }
@@ -204,14 +231,15 @@
     pipe_reference_init(&vsrf->refcnt, 1);
     p_atomic_set(&vsrf->validated, 0);
     vsrf->screen = vws;
-    vsrf->sid = whandle->handle;
+    vsrf->sid = handle;
     ssrf = svga_winsys_surface(vsrf);
     *format = rep->format;
 
     return ssrf;
 
 out_mip:
-    vmw_ioctl_surface_destroy(vws, whandle->handle);
+    vmw_ioctl_surface_destroy(vws, handle);
+
     return NULL;
 }
 
@@ -221,7 +249,9 @@
 			   unsigned stride,
 			   struct winsys_handle *whandle)
 {
+    struct vmw_winsys_screen *vws = vmw_winsys_screen(sws);
     struct vmw_svga_winsys_surface *vsrf;
+    int ret;
 
     if (!surface)
 	return FALSE;
@@ -230,5 +260,24 @@
     whandle->handle = vsrf->sid;
     whandle->stride = stride;
 
+    switch (whandle->type) {
+    case DRM_API_HANDLE_TYPE_SHARED:
+    case DRM_API_HANDLE_TYPE_KMS:
+       whandle->handle = vsrf->sid;
+       break;
+    case DRM_API_HANDLE_TYPE_FD:
+       ret = drmPrimeHandleToFD(vws->ioctl.drm_fd, vsrf->sid, DRM_CLOEXEC,
+				(int *)&whandle->handle);
+       if (ret) {
+	  vmw_error("Failed to get file descriptor from prime.\n");
+	  return FALSE;
+       }
+       break;
+    default:
+       vmw_error("Attempt to export unsupported handle type %d.\n",
+		 whandle->type);
+       return FALSE;
+    }
+
     return TRUE;
 }
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -44,6 +44,8 @@
 #include "gbm_driint.h"
 
 #include "gbmint.h"
+#include <xf86drm.h>
+
 
 /* For importing wl_buffer */
 #if HAVE_WAYLAND_PLATFORM
@@ -132,7 +134,7 @@
 };
 
 static const __DRIdri2LoaderExtension dri2_loader_extension = {
-   { __DRI_DRI2_LOADER, 3 },
+   { __DRI_DRI2_LOADER, 4 },
    dri_get_buffers,
    dri_flush_front_buffer,
    dri_get_buffers_with_format,
@@ -327,9 +329,11 @@
    switch (format) {
    case GBM_BO_FORMAT_XRGB8888:
    case GBM_FORMAT_XRGB8888:
+   case GBM_FORMAT_XBGR8888:
       break;
    case GBM_BO_FORMAT_ARGB8888:
    case GBM_FORMAT_ARGB8888:
+   case GBM_FORMAT_ABGR8888:
       if (usage & GBM_BO_USE_SCANOUT)
          return 0;
       break;
@@ -394,6 +398,9 @@
    case __DRI_IMAGE_FORMAT_ABGR8888:
       ret = GBM_FORMAT_ABGR8888;
       break;
+   case __DRI_IMAGE_FORMAT_XBGR8888:
+      ret = GBM_FORMAT_XBGR8888;
+      break;
    default:
       ret = 0;
       break;
@@ -402,6 +409,41 @@
    return ret;
 }
 
+static uint32_t
+gbm_to_dri_format(uint32_t gbm_format)
+{
+   uint32_t dri_format = 0;
+
+   switch (gbm_format) {
+   case GBM_FORMAT_RGB565:
+      dri_format =__DRI_IMAGE_FORMAT_RGB565;
+      break;
+   case GBM_FORMAT_XRGB8888:
+   case GBM_BO_FORMAT_XRGB8888:
+      dri_format = __DRI_IMAGE_FORMAT_XRGB8888;
+      break;
+   case GBM_FORMAT_ARGB8888:
+   case GBM_BO_FORMAT_ARGB8888:
+      dri_format = __DRI_IMAGE_FORMAT_ARGB8888;
+      break;
+   case GBM_FORMAT_ABGR8888:
+      dri_format = __DRI_IMAGE_FORMAT_ABGR8888;
+      break;
+   case GBM_FORMAT_ARGB2101010:
+      dri_format = __DRI_IMAGE_FORMAT_ARGB2101010;
+      break;
+   case GBM_FORMAT_XRGB2101010:
+      dri_format = __DRI_IMAGE_FORMAT_XRGB2101010;
+   case GBM_FORMAT_XBGR8888:
+      dri_format = __DRI_IMAGE_FORMAT_XBGR8888;
+      break;
+   default:
+      dri_format = __DRI_IMAGE_FORMAT_NONE;
+   }
+
+   return dri_format;
+}
+
 static struct gbm_bo *
 gbm_dri_bo_import(struct gbm_device *gbm,
                   uint32_t type, void *buffer, uint32_t usage)
@@ -585,30 +627,7 @@
    bo->base.base.height = height;
    bo->base.base.format = format;
 
-   switch (format) {
-   case GBM_FORMAT_RGB565:
-      dri_format =__DRI_IMAGE_FORMAT_RGB565;
-      break;
-   case GBM_FORMAT_XRGB8888:
-   case GBM_BO_FORMAT_XRGB8888:
-      dri_format = __DRI_IMAGE_FORMAT_XRGB8888;
-      break;
-   case GBM_FORMAT_ARGB8888:
-   case GBM_BO_FORMAT_ARGB8888:
-      dri_format = __DRI_IMAGE_FORMAT_ARGB8888;
-      break;
-   case GBM_FORMAT_ABGR8888:
-      dri_format = __DRI_IMAGE_FORMAT_ABGR8888;
-      break;
-   case GBM_FORMAT_ARGB2101010:
-      dri_format = __DRI_IMAGE_FORMAT_ARGB2101010;
-      break;
-   case GBM_FORMAT_XRGB2101010:
-      dri_format = __DRI_IMAGE_FORMAT_XRGB2101010;
-      break;
-   default:
-      return NULL;
-   }
+   dri_format = gbm_to_dri_format(format);
 
    if (usage & GBM_BO_USE_SCANOUT)
       dri_use |= __DRI_IMAGE_USE_SCANOUT;
--- a/src/mesa/drivers/dri/i915/intel_context.c
+++ b/src/mesa/drivers/dri/i915/intel_context.c
@@ -791,24 +791,36 @@
     */
    if (rb->mt &&
        rb->mt->region &&
-       rb->mt->region->name == buffer->name)
+       rb->mt->region->name == buffer->name &&
+       rb->mt->region->name != 0)
       return;
 
    if (unlikely(INTEL_DEBUG & DEBUG_DRI)) {
       fprintf(stderr,
-	      "attaching buffer %d, at %d, cpp %d, pitch %d\n",
+	      "attaching buffer %d, at %d, cpp %d, pitch %d, fd %d\n",
 	      buffer->name, buffer->attachment,
-	      buffer->cpp, buffer->pitch);
+	      buffer->cpp, buffer->pitch, buffer->fd);
    }
 
    intel_miptree_release(&rb->mt);
-   region = intel_region_alloc_for_handle(intel->intelScreen,
-                                          buffer->cpp,
-                                          drawable->w,
-                                          drawable->h,
-                                          buffer->pitch,
-                                          buffer->name,
-                                          buffer_name);
+   if (buffer->name != 0) {
+      region = intel_region_alloc_for_handle(intel->intelScreen,
+                                             buffer->cpp,
+                                             drawable->w,
+                                             drawable->h,
+                                             buffer->pitch,
+                                             buffer->name,
+                                             buffer_name);
+   } else {
+      region = intel_region_alloc_for_fd(intel->intelScreen,
+                                         buffer->cpp,
+                                         drawable->w,
+                                         drawable->h,
+                                         buffer->pitch,
+                                         0, /* Can we be so silly? */
+                                         buffer->fd,
+                                         buffer_name);
+   }
    if (!region)
       return;
 
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -1021,7 +1021,7 @@
                           struct intel_renderbuffer *rb,
                           const char *buffer_name);
 
-static void
+static bool
 intel_update_image_buffers(struct brw_context *brw, __DRIdrawable *drawable);
 
 static void
@@ -1094,9 +1094,8 @@
    if (unlikely(INTEL_DEBUG & DEBUG_DRI))
       fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);
 
-   if (screen->image.loader)
-      intel_update_image_buffers(brw, drawable);
-   else
+   /* Try using the Image loader extension; if that fails, fall back to DRI2 */
+   if (!screen->image.loader || !intel_update_image_buffers(brw, drawable))
       intel_update_dri2_buffers(brw, drawable);
 
    driUpdateFramebufferSize(&brw->ctx, drawable);
@@ -1268,13 +1267,15 @@
    if (num_samples == 0) {
        if (rb->mt &&
            rb->mt->region &&
-           rb->mt->region->name == buffer->name)
+           rb->mt->region->name == buffer->name &&
+           rb->mt->region->name != 0)
           return;
    } else {
        if (rb->mt &&
            rb->mt->singlesample_mt &&
            rb->mt->singlesample_mt->region &&
-           rb->mt->singlesample_mt->region->name == buffer->name)
+           rb->mt->singlesample_mt->region->name == buffer->name &&
+           rb->mt->singlesample_mt->region->name != 0)
           return;
    }
 
@@ -1286,13 +1287,24 @@
    }
 
    intel_miptree_release(&rb->mt);
-   region = intel_region_alloc_for_handle(brw->intelScreen,
-                                          buffer->cpp,
-                                          drawable->w,
-                                          drawable->h,
-                                          buffer->pitch,
-                                          buffer->name,
-                                          buffer_name);
+   if (buffer->name != 0) {
+      region = intel_region_alloc_for_handle(brw->intelScreen,
+                                             buffer->cpp,
+                                             drawable->w,
+                                             drawable->h,
+                                             buffer->pitch,
+                                             buffer->name,
+                                             buffer_name);
+   } else {
+      region = intel_region_alloc_for_fd(brw->intelScreen,
+                                         buffer->cpp,
+                                         drawable->w,
+                                         drawable->h,
+                                         buffer->pitch,
+                                         drawable->h * buffer->pitch,
+                                         buffer->fd,
+                                         buffer_name);
+   }
    if (!region)
       return;
 
@@ -1347,7 +1359,7 @@
                                                   region);
 }
 
-static void
+static bool
 intel_update_image_buffers(struct brw_context *brw, __DRIdrawable *drawable)
 {
    struct gl_framebuffer *fb = drawable->driverPrivate;
@@ -1366,7 +1378,7 @@
    else if (front_rb)
       format = intel_rb_format(front_rb);
    else
-      return;
+      return false;
 
    if ((brw->is_front_buffer_rendering || brw->is_front_buffer_reading || !back_rb) && front_rb)
       buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;
@@ -1374,12 +1386,13 @@
    if (back_rb)
       buffer_mask |= __DRI_IMAGE_BUFFER_BACK;
 
-   (*screen->image.loader->getBuffers) (drawable,
-                                        driGLFormatToImageFormat(format),
-                                        &drawable->dri2.stamp,
-                                        drawable->loaderPrivate,
-                                        buffer_mask,
-                                        &images);
+   if (!(*screen->image.loader->getBuffers) (drawable,
+                                             driGLFormatToImageFormat(format),
+                                             &drawable->dri2.stamp,
+                                             drawable->loaderPrivate,
+                                             buffer_mask,
+                                             &images))
+      return false;
 
    if (images.image_mask & __DRI_IMAGE_BUFFER_FRONT) {
       drawable->w = images.front->width;
@@ -1399,4 +1412,5 @@
                                 images.back,
                                 __DRI_IMAGE_BUFFER_BACK);
    }
+   return true;
 }
--- a/src/gallium/targets/r300/drm_target.c
+++ b/src/gallium/targets/r300/drm_target.c
@@ -51,4 +51,29 @@
    return sws->screen;
 }
 
-DRM_DRIVER_DESCRIPTOR("r300", "radeon", create_screen, NULL)
+/* Technically this is only true for kernels >= 3.12, which
+ * support lseek on dma-buf fds.
+ *
+ * We could check for this in create_screen and return the correct
+ * value, but for now just return true in all cases.
+ * 
+ * createImageFromFds fails gracefully on kernel < 3.12, so this
+ * shouldn't be a huge problem.
+ */
+static const struct drm_conf_ret share_fd_ret = {
+   .type = DRM_CONF_BOOL,
+   .val.val_int = true,
+};
+
+static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
+{
+   switch (conf) {
+   case DRM_CONF_SHARE_FD:
+      return &share_fd_ret;
+   default:
+      break;
+   }
+   return NULL;
+}
+
+DRM_DRIVER_DESCRIPTOR("r300", "radeon", create_screen, drm_configuration)
--- a/src/gallium/targets/r600/drm_target.c
+++ b/src/gallium/targets/r600/drm_target.c
@@ -55,11 +55,27 @@
    .val.val_int = 2,
 };
 
+/* Technically this is only true for kernels >= 3.12, which
+ * support lseek on dma-buf fds.
+ *
+ * We could check for this in create_screen and return the correct
+ * value, but for now just return true in all cases.
+ * 
+ * createImageFromFds fails gracefully on kernel < 3.12, so this
+ * shouldn't be a huge problem.
+ */
+static const struct drm_conf_ret share_fd_ret = {
+   .type = DRM_CONF_BOOL,
+   .val.val_int = true,
+};
+
 static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
 {
    switch (conf) {
    case DRM_CONF_THROTTLE:
       return &throttle_ret;
+   case DRM_CONF_SHARE_FD:
+      return &share_fd_ret;
    default:
       break;
    }
--- a/src/gallium/targets/radeonsi/drm_target.c
+++ b/src/gallium/targets/radeonsi/drm_target.c
@@ -55,11 +55,27 @@
    .val.val_int = 2,
 };
 
+/* Technically this is only true for kernels >= 3.12, which
+ * support lseek on dma-buf fds.
+ *
+ * We could check for this in create_screen and return the correct
+ * value, but for now just return true in all cases.
+ * 
+ * createImageFromFds fails gracefully on kernel < 3.12, so this
+ * shouldn't be a huge problem.
+ */
+static const struct drm_conf_ret share_fd_ret = {
+   .type = DRM_CONF_BOOL,
+   .val.val_int = true,
+};
+
 static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
 {
    switch (conf) {
    case DRM_CONF_THROTTLE:
       return &throttle_ret;
+   case DRM_CONF_SHARE_FD:
+      return &share_fd_ret;
    default:
       break;
    }
